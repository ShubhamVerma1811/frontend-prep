<h1>Architecture and High-Level Design in Frontend System Design</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1692"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39.png"
    alt="Frontend System Design Component Design"
    width="1920"
    height="1080"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39.png          1920w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39-300x169.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39-1024x576.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39-768x432.png   768w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-39-1536x864.png 1536w
    "
    sizes="(max-width: 1920px) 100vw, 1920px"
  />
</p>
<hr />
<p>
  The architecture portion of front-end system design interviews is arguably
  one, if not the most critical and time-consuming portion of the interview. The
  point of this round is for you to show how you’d lay out your component
  hierarchy and how all of those pieces connect within your front-end
  infrastructure.
</p>
<blockquote>
  <p>
    <i
      ><b
        >Start by spending 20% of your interview discussing high-level
        architecture design, and then come back to this to add more features as
        you encounter them, all in all, 30% of your interview can be spent
        here.</b
      ></i
    >
  </p>
</blockquote>
<p>
  You can cover a lot of ground here, and you’ll probably return to this section
  as you explore topics like performance, state management, or data flow.
</p>
<p>
  For example, if you’re building an infinite scrolling list, you might first
  lay out your high-level components, then come back to explain how your
  <code>FeedList</code> component will use virtualization (like
  <code>react-window</code> or <code>react-virtualized</code>) and an
  <code>IntersectionObserver</code> to trigger new fetches.
</p>
<p>
  Considering the requirements, your goal is to develop a product/system
  architecture by identifying the key components of the product, how they
  interact with each other, and how they are related.
</p>
<p>
  Remember to focus on the <b>client-side architecture</b>, not the back end.
  Diagrams are your friends here. Each component can be represented using a
  rectangle. Your high-level design usually resembles a few rectangular boxes
  with arrows between them to demonstrate the data flow.
</p>
<p>
  It is also possible to have components within components; in that case, draw
  the parent using bigger rectangles since they need to fit multiple
  subcomponents.
</p>
<p>
  Think about breaking your components into individual parts. Each part provides
  its specific purpose.
</p>
<hr />
<h3>Diagramming Your Architecture</h3>
<p>
  You’ll need to draw or outline your component hierarchy clearly. Most
  interviewers expect some visuals.
</p>
<p>
  You will generally either design this artwork diagram virtually using one of
  the tools below or, if in person, draw it on a whiteboard.
</p>
<ul>
  <li>
    <a href="https://lucidchart.com" rel="noreferrer">LucidChart</a>: This is a
    paid platform for drawing diagrams with many features.
  </li>
  <li>
    <a href="https://excalidraw.com/">Excalidraw</a>: A user-friendly tool for
    creating hand-drawn-like diagrams.
  </li>
  <li>
    <a href="https://app.diagrams.net/">diagrams.net</a>: A versatile tool for
    creating diagrams and flowcharts.
  </li>
</ul>
<p>
  Practice sketching standard layouts so you’re not fumbling with tools during
  the interview.
</p>
<hr />
<h3>Backend Blackbox</h3>
<p>
  In front-end system design interviews, we can treat the server as a black box
  and assume it exposes some APIs you can call via HTTP/WebSockets. The server
  handles client requests, processes them, and returns the appropriate
  responses. It can also manage data storage and retrieval, ensuring the client
  can access the necessary information.
</p>
<p>
  The only time you may need to discuss the backend is during
  <a href="https://frontendlead.com/system-design/api-design-best-practices"
    >API</a
  >
  design, more on that in the following few articles. Even still, you
  won&#8217;t be asked to build the table schemas, etc, more about the expected
  request and response from the backend.
</p>
<p>
  Now, if you are in a full-stack loop, then yes, study up on backend
  principles.
  <a
    href="https://frontendlead.com/system-design/general-system-design-fundamentals"
    >Here</a
  >
  is an article that walks you through backend fundamentals. Clarify with your
  interviewer how much you should speak about the front end vs. the backend.
</p>
<p>
  Is it 50/50, 30/70, etc, that can help you guide your interview immediately.
</p>
<hr />
<h3>Focus on the Client-Side</h3>
<p>
  Remember, your job is to lay out the
  <strong>client-side architecture</strong>. Don’t get bogged down in the
  backend unless asked to. You want to separate concerns: parent containers,
  dumb/presentational components, smart containers, reusable UI widgets, etc.
</p>
<hr />
<h3>Separation of Concern (MVC vs MVVM)</h3>
<p>
  There’s no single correct answer here. I like using the MVVM
  (Model-View-ViewModel) pattern because it creates a clean separation between
  business logic, state, and UI layers. However, MVC (Model-View-Controller) and
  similar patterns are also totally valid. The main thing is that your
  architecture is organized and clear, and you can explain why you chose it.
</p>
<h3>Examples</h3>
<p>I’ll show two example architectures:</p>
<ol>
  <li><strong>Airbnb Front-End (MVVM Example)</strong></li>
  <li><strong>Sprint Board (MVC Example)</strong></li>
</ol>
<h3>Commonalities between the two</h3>
<ul>
  <li>
    <strong>Component Hierarchy:</strong> Show how you break down the UI into
    logical, reusable pieces.
  </li>
  <li>
    <strong>Separation of Concerns:</strong> Make it clear what each component
    is responsible for. Keep business logic out of pure UI components.
  </li>
  <li>
    <strong>Reusability:</strong> Identify which components can be reused
    elsewhere in the app.
  </li>
  <li>
    <strong>Data Flow:</strong> Sketch out where state lives (local vs global),
    how it moves between components, and how components communicate (props,
    context, events, etc.).
  </li>
  <li>
    <strong>Extensibility:</strong> Briefly mention how your architecture could
    adapt as features grow.
  </li>
</ul>
<h3>Tip</h3>
<p>
  Please return to this diagram and update it as you answer follow-up questions
  about features, performance, or scaling. Don’t be afraid to revise your
  architecture in real time; it shows you can adapt as new requirements arise.
</p>
<hr />
<h2>Design a Simple Airbnb Client Architecture (MVVM)</h2>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1654"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2025-05-18-at-1.08.39-PM.png"
    alt="Design Airbnb - Frontend System Design"
    width="887"
    height="873"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2025-05-18-at-1.08.39-PM.png         887w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2025-05-18-at-1.08.39-PM-300x295.png 300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2025-05-18-at-1.08.39-PM-768x756.png 768w
    "
    sizes="(max-width: 887px) 100vw, 887px"
  />
</p>
<p>
  This diagram lays out a modern frontend architecture using the MVVM pattern,
  and is typical of what you’d want to describe in a system design interview.
</p>
<p>Let’s walk through each piece and how the data flows.</p>
<hr />
<h3>High-Level Overview</h3>
<p>
  Everything here lives on the client. The client&#8217;s main job is to manage
  routing, state, business logic, rendering, and optimizations like image
  loading and caching.
</p>
<h4>User &amp; Routing</h4>
<ul>
  <li>
    <strong>User → React Router</strong><br />
    The user interacts with the app, which React Router manages. Based on the
    URL, routing determines which screen (or view) to show.
  </li>
</ul>
<hr />
<h4>MVVM Layers</h4>
<ul>
  <li>
    <strong>View Model</strong><br />
    This is the main bridge between the UI and your business logic. It talks to
    the network layer (for API calls), manages local state with something like
    React Context (shown here as &#8220;Store&#8221;), and prepares data for the
    UI to consume.
    <ul>
      <li>
        Please consider the View Model, the smart layer: it fetches data,
        manages state, and exposes exactly what the view needs.
      </li>
    </ul>
  </li>
  <li>
    <strong>Store (useContext)</strong><br />
    The Store holds shared app state, such as user sessions, cached data,
    feature toggles, etc., and lets the View Model read/write to it.
    <ul>
      <li>Context API, Redux, Zustand, or similar could power a React app.</li>
    </ul>
  </li>
  <li>
    <strong>Network</strong><br />
    It handles all API requests. The View Model calls the network to fetch or
    post data and then updates the Store as needed.
  </li>
</ul>
<hr />
<h4>View Layer</h4>
<ul>
  <li>
    <strong><code>&lt;BookingsListContainer /&gt;</code></strong
    ><br />
    The container component connects to the View Model (typically via a
    <code>useViewModel</code> hook). It orchestrates fetching data and renders
    the correct UI components.
    <ul>
      <li>
        This keeps the UI layer as dumb as possible; it just renders what it’s
        given.
      </li>
    </ul>
  </li>
  <li>
    <strong><code>&lt;VirtualizedList/&gt;</code></strong
    ><br />
    To handle infinite scrolling efficiently, we use a virtualized list. This
    only renders items in the viewport, boosting performance and smooth
    scrolling.
  </li>
  <li>
    <strong
      ><code>&lt;BookingCard/&gt;</code>,
      <code>&lt;ImageSlideshow/&gt;</code></strong
    ><br />
    These are presentational components nested inside the virtualized list. Each
    is focused on rendering a specific part of the UI and receives all its data
    via props from the parent/container.
  </li>
</ul>
<hr />
<h4>Image Optimization</h4>
<ul>
  <li>
    <strong><code>Image Manager</code> &amp; <code>Cache</code></strong
    ><br />
    Image-heavy apps need brilliant image handling. The Image Manager decides
    when and how to fetch images, pulls from the Image Cache if available, and
    requests new photos from the Image Service (usually via API).
  </li>
  <li>
    <strong><code>Image Service</code></strong
    ><br />
    A backend service for fetching, resizing, or optimizing images on demand.
  </li>
</ul>
<hr />
<h4>API Layer</h4>
<ul>
  <li>
    The only way to contact the backend is through the network layer&#8217;s
    API. Everything else is client-side.
  </li>
</ul>
<hr />
<h3>Why This Architecture Works</h3>
<ul>
  <li>
    <strong>Clear separation of concerns:</strong><br />
    Business logic (View Model), state (Store), rendering (View), and resource
    management (Image Manager/Cache) are all isolated and testable.
  </li>
  <li>
    <strong>Extensible:</strong><br />
    Easy to add features like offline caching, loading states, error boundaries,
    and analytics.
  </li>
  <li>
    <strong>Performant:</strong><br />
    Virtualized lists and aggressive image caching reduce client memory and
    boost UX.
  </li>
  <li>
    <strong>Testable and maintainable:</strong><br />
    UI components are as dumb as possible. State and logic changes are isolated
    and easy to cover with unit tests.
  </li>
</ul>
<hr />
<h3>How to Use This in an Interview</h3>
<p>
  Talk through each piece, and show how data and user actions flow through the
  system. Point out how you’d handle edge cases (loading, errors, caching) and
  how each layer could be extended for future requirements (adding chat, more
  media, new screens, etc.).
</p>
<p>You want your interviewer to see that you’re thinking about:</p>
<ul>
  <li>Modularity</li>
  <li>Performance</li>
  <li>Scalability</li>
  <li>Real-world UX tradeoffs</li>
</ul>
<p>
  That’s the goal with a diagram like this. If you’re asked to go deeper, you
  can pick any part (like image caching or the virtualized list) and explain
  exactly how you’d implement it.
</p>
<hr />
<h3>Here is the same diagram but using pseudocode:</h3>
<pre><code>
&lt;!-- High-level pseudocode example based on the frontend architecture diagram --&gt;

&lt;!-- App entry point --&gt;
&lt;App&gt;
&lt;Router&gt;
&lt;!-- Handles navigation between different screens --&gt;
&lt;Route path="/bookings"&gt;
&lt;BookingsListContainer /&gt;
&lt;/Route&gt;
&lt;!-- ...other routes --&gt;
&lt;/Router&gt;
&lt;/App&gt;

&lt;!-- Bookings List Container (MVVM pattern) --&gt;
&lt;BookingsListContainer&gt;
&lt;!-- useViewModel() handles business logic, state, API calls --&gt;
&lt;BookingsListContainerView&gt;
&lt;BookingsList&gt;
&lt;!-- Render a list of bookings --&gt;
&lt;BookingsCard&gt;
&lt;ImageSlideShow /&gt;
&lt;/BookingsCard&gt;
&lt;!-- Repeat BookingsCard for each booking --&gt;
&lt;/BookingsList&gt;
&lt;/BookingsListContainerView&gt;
&lt;/BookingsListContainer&gt;

&lt;!-- ViewModel logic (abstracted) --&gt;
&lt;!--
useViewModel() {
// Fetch data from API using the network layer
// Interact with Store (useContext or other state management)
// Return state and actions for the UI
}
--&gt;

&lt;!-- ImgManager component handles image requests and caching --&gt;
&lt;!--
ImgManager(src) {
// Check ImageCache first
// If not cached, fetch from ImageService
// Preload images, manage cache eviction
}
--&gt;

&lt;!-- ImageCache could use memory, IndexedDB, or browser cache --&gt;

&lt;!-- ImageService interacts with backend to fetch/optimize images --&gt;

&lt;!-- BookingCard and ImageSlideShow are presentational components --&gt;</code></pre>

<div aria-hidden="true" data-edge="true"></div>
<div aria-hidden="true" data-edge="true">
  Deeper dive on how to use
  <a href="https://frontendlead.com/handbook/mvvm-in-react">MVVM in React</a>.
</div>
<div aria-hidden="true" data-edge="true"></div>
<div aria-hidden="true" data-edge="true">
  Now, let&#8217;s compare this to a MVC model using the sprint board example.
</div>
<hr />
<h2>Design a Sprint Board Client Architecture (MVC)</h2>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1404"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-10.34.06-AM-1.png"
    alt=""
    width="1140"
    height="878"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-10.34.06-AM-1.png          1140w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-10.34.06-AM-1-300x231.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-10.34.06-AM-1-1024x789.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-10.34.06-AM-1-768x591.png   768w
    "
    sizes="(max-width: 1140px) 100vw, 1140px"
  />
</p>
<p class="" data-start="228" data-end="415">
  This diagram describes a classic frontend architecture using the MVC
  (Model-View-Controller) pattern. It is precisely the style of answer you’d
  want to provide in a system design interview.
</p>
<p class="" data-start="417" data-end="500">
  Let’s break down each section and see how data and actions flow through the
  system.
</p>
<h3 class="" data-start="502" data-end="525">High-Level Overview</h3>
<p class="" data-start="527" data-end="743">
  Everything here lives on the client. The client’s job is to manage the board
  state, handle user interactions (like creating a new board or moving tickets),
  trigger server updates, and reflect those changes in the UI.
</p>
<hr class="" data-start="745" data-end="748" />
<h3 class="" data-start="750" data-end="785">
  User Actions &amp; Controller Layer
</h3>
<p class="" data-start="787" data-end="805">
  <strong data-start="787" data-end="803">User Actions</strong>
</p>
<ul data-start="806" data-end="927">
  <li class="" data-start="806" data-end="927">
    <p class="" data-start="808" data-end="927">
      The user creates a new board or interacts with existing tickets (e.g.,
      dragging and dropping to a new column, updating a ticket).
    </p>
  </li>
</ul>
<p class="" data-start="929" data-end="962">
  <strong data-start="929" data-end="962">Board Controller (Controller)</strong>
</p>
<ul data-start="963" data-end="1214">
  <li class="" data-start="963" data-end="1012">
    <p class="" data-start="965" data-end="1012">
      The Board Controller receives all user actions.
    </p>
  </li>
  <li class="" data-start="1013" data-end="1159">
    <p class="" data-start="1015" data-end="1159">
      For example, when a ticket is dragged to a new column, the controller
      processes that interaction, updates the state, and coordinates server
      updates.
    </p>
  </li>
  <li class="" data-start="1160" data-end="1214">
    <p class="" data-start="1162" data-end="1214">
      Separates concerns: keeps logic out of the UI layer.
    </p>
  </li>
</ul>
<hr class="" data-start="1216" data-end="1219" />
<h3 class="" data-start="1221" data-end="1238">Example Flows</h3>
<h4 class="" data-start="1240" data-end="1265">Creating a New Board</h4>
<ul data-start="1266" data-end="1501">
  <li class="" data-start="1266" data-end="1306">
    <p class="" data-start="1268" data-end="1306">
      The user clicks to create a new board.
    </p>
  </li>
  <li class="" data-start="1307" data-end="1357">
    <p class="" data-start="1309" data-end="1357">
      The Board Controller handles the creation logic.
    </p>
  </li>
  <li class="" data-start="1358" data-end="1417">
    <p class="" data-start="1360" data-end="1417">
      Sends the request to the Controller and Data Model Store.
    </p>
  </li>
  <li class="" data-start="1418" data-end="1501">
    <p class="" data-start="1420" data-end="1501">
      Updates are reflected in the Data Model, and the UI rerenders the new
      board view.
    </p>
  </li>
</ul>
<h4 class="" data-start="1503" data-end="1533">Updating Existing Tickets</h4>
<ul data-start="1534" data-end="1876">
  <li class="" data-start="1534" data-end="1767">
    <p class="" data-start="1536" data-end="1560">The user drags a ticket:</p>
    <ul data-start="1563" data-end="1767">
      <li class="" data-start="1563" data-end="1617">
        <p class="" data-start="1565" data-end="1617">
          <strong data-start="1565" data-end="1580">Drag Start:</strong> The
          Controller starts tracking the drag.
        </p>
      </li>
      <li class="" data-start="1620" data-end="1688">
        <p class="" data-start="1622" data-end="1688">
          <strong data-start="1622" data-end="1635">Drag End:</strong> When
          dropped, the controller gets the new column ID.
        </p>
      </li>
      <li class="" data-start="1691" data-end="1767">
        <p class="" data-start="1693" data-end="1767">
          <strong data-start="1693" data-end="1711">Server Update:</strong> The
          controller triggers a server update for the change.
        </p>
      </li>
    </ul>
  </li>
  <li class="" data-start="1768" data-end="1876">
    <p class="" data-start="1770" data-end="1876">
      Once confirmed, the controller updates the Data Model Store, and the UI
      reflects the updated ticket state.
    </p>
  </li>
</ul>
<hr class="" data-start="1878" data-end="1881" />
<h3 class="" data-start="1883" data-end="1892">Views</h3>
<p class="" data-start="1894" data-end="1907">
  <strong data-start="1894" data-end="1907">Views Box</strong>
</p>
<ul data-start="1908" data-end="2194">
  <li class="" data-start="1908" data-end="1987">
    <p class="" data-start="1910" data-end="1987">
      Contains all UI elements, including the Sprint Board and the Create
      Composer.
    </p>
  </li>
  <li class="" data-start="1988" data-end="2066">
    <p class="" data-start="1990" data-end="2066">
      Each of these views contains child components and handles user
      interactions.
    </p>
  </li>
  <li class="" data-start="2067" data-end="2194">
    <p class="" data-start="2069" data-end="2194">
      These are the “dumb” view layers; they render what the controller and
      model provide, and never handle business logic directly.
    </p>
  </li>
</ul>
<hr class="" data-start="2196" data-end="2199" />
<h3 class="" data-start="2201" data-end="2234">
  Controller &amp; Data Model Store
</h3>
<ul data-start="2236" data-end="2552">
  <li class="" data-start="2236" data-end="2332">
    <p class="" data-start="2238" data-end="2332">
      <strong data-start="2238" data-end="2253">Controller:</strong> Acts as the
      central logic hub, handling data flow between the view and the model.
    </p>
  </li>
  <li class="" data-start="2333" data-end="2474">
    <p class="" data-start="2335" data-end="2474">
      <strong data-start="2335" data-end="2356">Data Model Store:</strong>
      Stores app state, manages updates, and ensures consistency between what
      the user sees and what’s stored in the model.
    </p>
  </li>
  <li class="" data-start="2475" data-end="2552">
    <p class="" data-start="2477" data-end="2552">
      <strong data-start="2477" data-end="2492">Data Model:</strong> The source
      of truth for all board, ticket, and column data.
    </p>
  </li>
</ul>
<hr class="" data-start="2554" data-end="2557" />
<h3 class="" data-start="2559" data-end="2590">Why This Architecture Works</h3>
<ul data-start="2592" data-end="3221">
  <li class="" data-start="2592" data-end="2822">
    <p class="" data-start="2594" data-end="2621">
      <strong data-start="2594" data-end="2619">Clear MVC Separation:</strong>
    </p>
    <ul data-start="2624" data-end="2822">
      <li class="" data-start="2624" data-end="2684">
        <p class="" data-start="2626" data-end="2684">
          Controller: Handles user actions and orchestrates updates.
        </p>
      </li>
      <li class="" data-start="2687" data-end="2759">
        <p class="" data-start="2689" data-end="2759">
          View: Renders state, receives updates, and reflects UI changes.
        </p>
      </li>
      <li class="" data-start="2762" data-end="2822">
        <p class="" data-start="2764" data-end="2822">
          Model: Stores data, updates state, syncs with the backend.
        </p>
      </li>
    </ul>
  </li>
  <li class="" data-start="2824" data-end="2952">
    <p class="" data-start="2826" data-end="2858">
      <strong data-start="2826" data-end="2856"
        >Testable and Maintainable:</strong
      >
    </p>
    <ul data-start="2861" data-end="2952">
      <li class="" data-start="2861" data-end="2899">
        <p class="" data-start="2863" data-end="2899">
          Logic is isolated in the controller.
        </p>
      </li>
      <li class="" data-start="2902" data-end="2952">
        <p class="" data-start="2904" data-end="2952">
          The view is pure UI and easy to test or replace.
        </p>
      </li>
    </ul>
  </li>
  <li class="" data-start="2954" data-end="3082">
    <p class="" data-start="2956" data-end="2973">
      <strong data-start="2956" data-end="2971">Extensible:</strong>
    </p>
    <ul data-start="2976" data-end="3082">
      <li class="" data-start="2976" data-end="3082">
        <p class="" data-start="2978" data-end="3082">
          Easy to add new features (e.g., new board actions, advanced ticket
          filtering, multi-user collaboration).
        </p>
      </li>
    </ul>
  </li>
  <li class="" data-start="3084" data-end="3221">
    <p class="" data-start="3086" data-end="3114">
      <strong data-start="3086" data-end="3112">Predictable Data Flow:</strong>
    </p>
    <ul data-start="3117" data-end="3221">
      <li class="" data-start="3117" data-end="3221">
        <p class="" data-start="3119" data-end="3221">
          All user actions are handled in the controller, keeping logic
          centralized and state changes traceable.
        </p>
      </li>
    </ul>
  </li>
</ul>
<hr class="" data-start="3223" data-end="3226" />
<h3 class="" data-start="3228" data-end="3263">
  How to Use This in an Interview
</h3>
<p class="" data-start="3265" data-end="3521">
  Talk through each part, and show how a user action (like dragging a ticket)
  travels through the controller, updates the model, and finally renders in the
  view. Point out how the controller and model store can handle server updates
  and optimistic UI.
</p>
<p class="" data-start="3523" data-end="3693">
  If asked to go deeper, you can walk through edge cases (conflicting updates,
  failed server responses, offline mode) and explain how MVC helps handle each
  scenario.
</p>
<hr class="" data-start="3695" data-end="3698" />
<h3 class="" data-start="3700" data-end="3735">
  Pseudocode for MVC Sprint Board
</h3>
<pre><code>
&lt;!-- High-level pseudocode based on the Sprint Board MVC architecture --&gt;

&lt;!-- App entry point --&gt;
&lt;App&gt;
&lt;!-- Main Controller handles all board actions --&gt;
&lt;BoardController&gt;
&lt;!-- Views handle rendering only --&gt;
&lt;SprintBoard&gt;
&lt;!-- Child Components for columns, tickets, etc. --&gt;
&lt;/SprintBoard&gt;
&lt;CreateComposer /&gt;
&lt;/BoardController&gt;
&lt;/App&gt;

&lt;!-- Example User Action Flow --&gt;
&lt;!--
User drags a ticket:
BoardController handles dragStart event
On dragEnd, BoardController gets new column id
BoardController sends update to DataModelStore
DataModelStore updates DataModel and triggers server update
On success, View rerenders with new ticket position
--&gt;

&lt;!-- DataModelStore maintains app state and syncs with backend --&gt;

&lt;!-- Views (SprintBoard, CreateComposer, Child Components) are dumb, render-only --&gt;

&lt;!-- DataModel is the source of truth for board/ticket/column data --&gt;
</code></pre>

<hr class="" data-start="4676" data-end="4679" />
<p class="" data-start="4681" data-end="4880">
  You want to use this approach to talk through a sprint board frontend using
  MVC.
</p>
<p class="" data-start="4681" data-end="4880">
  <br data-start="4772" data-end="4775" />Keep your answer clear, actionable,
  and easy to reference for whiteboard and live coding interviews.
</p>
<hr />
<h3>Additional Considerations for Front-End Architecture</h3>
<p>
  When designing the architecture for a front-end application, there are several
  additional considerations to keep in mind:
</p>
<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Performance</b></td>
      <td>
        Ensure that the application is responsive and performs well under
        various conditions. This can involve optimizing the UI rendering,
        minimizing the number of network requests, and reducing the size of the
        data being transferred. Techniques such as lazy loading, caching, and
        debouncing can help improve the application&#8217;s performance.
      </td>
    </tr>
    <tr>
      <td><b>Scalability</b></td>
      <td>
        Design the application to handle increasing users and data. This can
        involve using techniques such as pagination, infinite scrolling, and
        virtualized lists to manage large amounts of data. It can also include
        designing the architecture to support horizontal scaling, such as using
        load balancers and distributed data stores.
      </td>
    </tr>
    <tr>
      <td><b>Maintainability</b></td>
      <td>
        Ensure that the application is easy to maintain and extend. This can
        involve using modular components, following coding standards, and
        writing tests. It can also include managing the codebase using tools
        such as linters, code formatters, and version control systems.
      </td>
    </tr>
    <tr>
      <td><b>Security</b></td>
      <td>
        Protect the application from security threats like cross-site scripting
        (XSS), cross-site request forgery (CSRF), and SQL injection. This can
        involve using techniques such as input validation, output encoding, and
        secure communication protocols. It can also include the following best
        practices for authentication and authorization, such as using OAuth and
        JWT.
      </td>
    </tr>
    <tr>
      <td><b>User Experience</b></td>
      <td>
        Design the application to provide a positive user experience. This can
        involve using techniques such as responsive design, accessibility, and
        internationalization. It can also include the following best UI design
        practices: consistent layouts, straightforward navigation, and intuitive
        interactions.
      </td>
    </tr>
  </tbody>
</table>
<hr />
<p>
  If you are with me so far, congrats, because I know that wasn&#8217;t easy.
  The good news is that you can apply this architectural diagram system to any
  frontend system design interview forever.
</p>
<p>
  Now, let&#8217;s move <span
    style="box-sizing: border-box; margin: 0px; padding: 0px"
    >on to the <strong>(D) in R.A.D.I.O</strong>, the data model portion of the </span
  >Frontend System Design interview.
</p>
