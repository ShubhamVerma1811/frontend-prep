<h1>Design @mentions and #hashtags &#8211; Frontend System Design</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-624"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.26.51-PM.png"
    alt=""
    width="804"
    height="600"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.26.51-PM.png         804w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.26.51-PM-300x224.png 300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.26.51-PM-768x573.png 768w
    "
    sizes="(max-width: 804px) 100vw, 804px"
  />
</p>
<p>
  For this exercise, let&#8217;s construct an article structured around the task
  of building a system to support <code>@mentions</code> and
  <code>hashtags</code> within a WYSIWYG rich text editor, a common feature in
  modern social platforms and collaborative tools.
</p>
<p>
  Please do note, @mentions and rich text editor share a lot of common features,
  please do check out rich text editor
  <a href="https://frontendlead.com/system-design/rich-text-editor">here</a>.
</p>
<p><strong>Introduction</strong></p>
<p>
  In the dynamic landscape of web applications, the integration of
  <code>@mentions</code> and <code>hashtags</code> within text editors has
  evolved from a luxury to a near necessity. As developers, we are often tasked
  with creating systems that not only perform these functions but do so
  efficiently, accessibly, and across various devices and languages. This
  article will navigate through the construction of such a system, addressing
  the common functional and non-functional requirements, and highlighting
  optimizations and security measures necessary for a robust implementation.
</p>
<p>
  Full Diagram can be found
  <a
    href="https://lucid.app/documents/view/f919934a-ed77-49f8-a6de-47bc82d05dc3"
    >here</a
  >.
</p>
<h2><strong>Clarifying Questions</strong></h2>
<ul>
  <li>
    How should the system differentiate and prioritize
    <code>@mentions</code> vs. <code>hashtags</code>?
  </li>
  <li>What user data should be displayed in <code>@mention</code> results?</li>
  <li>
    At what user input threshold should the system begin querying for results?
  </li>
  <li>Should the list of mentions or hashtags support infinite scrolling?</li>
  <li>How frequently will the results be updated from the server?</li>
  <li>Are there any preferences on the latency and load performance?</li>
</ul>
<h2><strong>Functional Requirements</strong></h2>
<ul>
  <li>
    Support for rich text formatting, including bold, italics, and hyperlinks.
  </li>
  <li>
    Seamless integration of <code>@mention</code> and
    <code>#hashtag</code> functionality within the text editor.
  </li>
  <li>
    Displaying a popover list for both mentions and hashtags with real-time
    search results.
  </li>
  <li>
    Navigational links in popovers that redirect to detailed user profiles or
    hashtag summaries.
  </li>
  <li>
    Real-time updates to mention and hashtag lists based on the latest server
    data.
  </li>
</ul>
<h2><strong>Non-Functional Requirements</strong></h2>
<ul>
  <li>
    Implement efficient caching strategies to minimize server hits and enhance
    user experience.
  </li>
  <li>
    Decide between Server-Side Rendering (SSR) and Client-Side Rendering (CSR)
    based on initial load performance and SEO considerations.
  </li>
  <li>Mobile responsiveness to ensure usability across various devices.</li>
  <li>
    Pagination support, with a discussion on the merits of offset vs
    cursor-based approaches.
  </li>
  <li>
    High performance with low latency, potentially leveraging debouncing and
    normalized caching.
  </li>
  <li>Internationalization support for a global user base.</li>
  <li>
    Accessibility considerations, ensuring compliance with ARIA standards and
    cross-browser compatibility.
  </li>
  <li>
    Offline mode functionality, serving cached results when no network
    connection is available.
  </li>
  <li>
    Observability measures to track and optimize system performance and user
    interactions.
  </li>
  <li>
    Appropriate HTTP protocol selection to match the real-time or batched data
    requirements.
  </li>
</ul>
<h2><strong>Edgecases</strong></h2>
<p>
  Building a system to support <code>@mentions</code> and
  <code>hashtags</code> requires careful consideration of various edge cases to
  ensure a seamless user experience. Here are some potential edge cases and
  approaches for handling them:
</p>
<h2><strong>Handling Deletions</strong></h2>
<p>
  When a user decides to remove an <code>@mention</code> or a
  <code>#hashtag</code>, the system should:
</p>
<ul>
  <li>
    Recognize the deletion in real time and remove any associated styling or
    interactive elements.
  </li>
  <li>
    If part of a <code>mention</code> or <code>hashtag</code> is deleted,
    consider the entire entity as removed to avoid partial tags.
  </li>
  <li>
    Update the list of mentions or hashtags accordingly if they are being
    tracked or counted.
  </li>
</ul>
<h2><strong>Handling Undos</strong></h2>
<p>
  Undo functionality is vital in text editing. For <code>@mentions</code> and
  <code>hashtags</code>:
</p>
<ul>
  <li>
    Implement a stack to keep track of user actions to allow a step-by-step undo
    process.
  </li>
  <li>
    Ensure that undoing an action restores the previous state entirely,
    including text and associated metadata.
  </li>
</ul>
<h2><strong>Handling New Searches</strong></h2>
<p>
  When a user initiates a new search by typing <code>@</code> or <code>#</code>:
</p>
<ul>
  <li>
    Immediately trigger a debounce function to avoid overloading the server with
    requests during rapid typing.
  </li>
  <li>Cancel any ongoing searches that are no longer relevant.</li>
  <li>
    Display a loading state to inform the user that a search is in progress, if
    necessary.
  </li>
</ul>
<section>
  <h2>High-Level Architecture</h2>
  <p>
    <img
      loading="lazy"
      decoding="async"
      class="alignnone size-full wp-image-619"
      src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.07.09-PM.png"
      alt=""
      width="860"
      height="1264"
      srcset="
        https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.07.09-PM.png          860w,
        https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.07.09-PM-204x300.png  204w,
        https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.07.09-PM-697x1024.png 697w,
        https://api.frontendlead.com/wp-content/uploads/2024/03/Screenshot-2024-03-23-at-2.07.09-PM-768x1129.png 768w
      "
      sizes="(max-width: 860px) 100vw, 860px"
    />
  </p>
</section>
<p>&nbsp;</p>
<p>
  The high-level architecture for a WYSIWYG rich text editor can be segmented
  into several key components, each responsible for distinct aspects of the
  editorâ€™s functionality. The architecture diagram outlines the separation of
  concerns and depicts how user interactions are processed and rendered.
</p>
<p>
  <strong>Server and GraphQL (GQL) Layer</strong> The server forms the backbone
  of the rich text editor, interacting with the database and file storage
  systems to save and retrieve content. GraphQL sits as an intermediary between
  the server and client, providing a flexible API layer that allows the client
  to request exactly the data it needs. This can include not just the text
  content but also metadata, such as user permissions, versioning information,
  and linked multimedia resources.
</p>
<p>
  <strong>Model</strong> The Model represents the data structure and business
  logic of the editor. It stores the document state, including text, formatting
  attributes, and any embedded media. This state can be serialized for storage
  and transmitted to the server. The Model also exposes methods to manipulate
  the editor&#8217;s content programmatically, enabling operations like
  insertions, deletions, and formatting changes.
</p>
<p>
  <strong>Controller</strong> The Controller mediates interactions between the
  View and the Model. It handles user input, processes commands, and mediates
  the rendering of the content. The Controller receives events from the View,
  interprets them, and makes corresponding state changes to the Model. It
  ensures that the user&#8217;s intentions, as expressed through interactions
  with the View, are accurately reflected in the editor&#8217;s data model.
</p>
<p>
  <strong>Views</strong> The Views are the visual representation of the
  Model&#8217;s data. The Input Field View is the primary interface where users
  type and format their content. It listens for input events and requests the
  necessary updates from the Controller. The Popover View serves as an auxiliary
  interface for additional features like link editing or media insertion,
  providing a contextual UI that appears in response to specific user actions.
</p>
<p>
  <strong>Interactors</strong> Interactors (Field Interactor and Popover
  Interactor) are the conduits through which the Views communicate with the
  Controller. They listen for user actions, such as keystrokes, mouse clicks, or
  touch events, and translate them into operations on the Model via the
  Controller. The Interactors are also responsible for reflecting the state of
  the Model back onto the Views, ensuring the UI remains in sync with the
  underlying data.
</p>
<h2>API Design</h2>
<p>
  Our API design ensures seamless integration of @mentions and other dynamic
  content within a WYSIWYG rich text editor. Using GraphQL, we provide flexible
  and efficient querying capabilities.
</p>
<h3>GraphQL API Endpoints</h3>
<ul>
  <li>
    <strong>Fetching Mentions:</strong>
    <pre><code>query getMention($MentionInput) {
  id,
  type,
  title,
  url,
  photo,
  ... // additional metadata
}</code></pre>
  </li>
  <li>
    <strong>Fetching Profile Data:</strong>
    <pre><code>query getProfile($input) {
  name,
  photo
}</code></pre>
  </li>
  <li>
    <strong>Fetching Room Data:</strong>
    <pre><code>query getRoom($input) {
  name,
  photo
}</code></pre>
  </li>
  <li>
    <strong>Creating Mentions with Content:</strong>
    <pre><code>mutation createMessage($input) {
  text,
  metadata
}</code></pre>
  </li>
</ul>
<p>
  The APIs are authenticated using JWT headers, ensuring security and
  personalization. Whether we incorporate a WYSIWYG editor or not, our API
  design caters to the creation and retrieval of content-rich mentions.
</p>
<section>
  <h2>Data Model</h2>
  <p>
    The data model for the editor is a crucial aspect that dictates how text
    changes are processed and stored. Here is an interface that illustrates the
    structure and types of the editor&#8217;s properties, ensuring a controlled
    and predictable state.
  </p>
  <pre><code>
interface MessageInputProps {
  // Interactions
  onChange?: (currentTextJSON: string) =&gt; void;
  onSelect?: (selectedObject: any) =&gt; void;
  onBlur?: (event: Event) =&gt; void;
  autoFocus: boolean;
  onFetchResults: (page: number, size: number, type: string) =&gt; void;

// Styling
placeholder: string;
resultsRender: JSX.Element;
styling: StyleObject;
className: string;

// Network-related
debounceInterval: number;
showEmptyResults: boolean;
cacheTTL: number;
cacheType: 'in network' | 'apollo' | 'local' | 'session' | 'none';
networkTimeoutDuration: number; // in milliseconds
networkRetries: int;
}
</code></pre>
</section>
<section>
  <h2>Implementation Options</h2>
  <table>
    <thead>
      <tr>
        <th>Option</th>
        <th>Pros</th>
        <th>Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Use text area input field</td>
        <td>
          <ul>
            <li>Multiline support</li>
            <li>Unlimited characters</li>
            <li>Handles text input out of the box</li>
            <li>Browser support</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Does not support rich text content</li>
            <li>Have to absolute position edited elements</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>Use contentEditable</td>
        <td>
          <ul>
            <li>Supported by most browsers</li>
            <li>Support for native cursor</li>
            <li>Native input events, key bindings</li>
            <li>Accessibility friendly</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Need to customize rendering per browser</li>
            <li>Customized model required for state mapping</li>
            <li>UI consistency across browsers</li>
            <li>Complex manual build, cross-device issues</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>External Library (Lexical/Draft.js)</td>
        <td>
          <ul>
            <li>Battle-tested across platforms</li>
            <li>Extensive API</li>
            <li>Supports @mentions and hashtags</li>
            <li>Rich text support</li>
            <li>Accessibility friendly</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Limited customization</li>
            <li>Dependency on external code</li>
            <li>Increased code size</li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
  <h3>Why Option 3 is the Best Choice</h3>
  <p>
    Considering the needs for a robust, feature-rich, and user-friendly WYSIWYG
    editor, Option 3, utilizing an external library like Lexical or Draft.js,
    emerges as the best choice. While this option may introduce a dependency on
    external code and potentially increase the overall code size, the advantages
    it offers far outweigh these drawbacks.
  </p>
  <p>
    Lexical and Draft.js are battle-tested libraries that provide a wide array
    of features out-of-the-box, including rich text capabilities and support for
    modern web interactions like @mentions and hashtags. Furthermore, these
    libraries are designed with accessibility in mind, ensuring that the editor
    is usable for all individuals, regardless of their abilities.
  </p>
  <p>
    The extensive APIs offered by these libraries simplify the implementation of
    complex editing features, while their compatibility across different
    platforms and browsers ensures a consistent user experience. Although
    customization might be somewhat limited compared to building a solution from
    scratch, the trade-off is a more reliable and maintainable codebase that
    leverages the collective knowledge and expertise of the developer community.
  </p>
</section>
<p>&nbsp;</p>
<h1>Optimizations</h1>
<section>
  <h2>Debouncing User Input</h2>
  <p>
    To enhance performance and reduce unnecessary load, user input can be
    debounced. This technique involves waiting for a certain amount of idle time
    before processing input, thereby limiting the rate at which events like
    keystrokes trigger updates in the editor state or re-rendering of the
    component.
  </p>
  <p>
    Implementing debouncing ensures that the system is not overwhelmed by the
    high frequency of user actions, which is particularly beneficial when these
    actions lead to complex processing tasks or network requests, like fetching
    suggestions for @mentions or updating the live preview of the content.
  </p>
  <pre><code>
function debounce(func, wait) {
  let timeout;

return function executedFunction(...args) {
const later = function() {
clearTimeout(timeout);
func(...args);
};

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

};
};

// Usage with a function that updates the editor state
const debouncedUpdate = debounce(updateEditorState, 250);
</code></pre>
</section>
<section>
  <h2>Caching Strategy</h2>
  <p>
    Caching is a crucial optimization strategy for a WYSIWYG editor. It allows
    us to store previously retrieved or computed data, such as user input,
    images, or document snapshots, so that future requests for the same data can
    be served faster.
  </p>
  <p>
    The editor can implement a caching layer that stores the state of the editor
    or parts of it in memory. It can also persist data locally on the
    client&#8217;s machine using browser caching mechanisms like LocalStorage,
    IndexedDB, or Service Workers, which is particularly useful for offline
    capabilities and to quickly restore the state when the user returns to the
    editor.
  </p>
  <pre><code>
// Example of a simple in-memory cache implementation
class EditorCache {
  constructor() {
    this.cache = {};
  }

get(key) {
return this.cache[key];
}

set(key, value) {
this.cache[key] = value;
}
}

const cache = new EditorCache();
// Store and retrieve the editor state
cache.set('editorState', editorState);
const cachedState = cache.get('editorState');
</code></pre>

  <p>
    The caching strategy also involves setting a Time To Live (TTL) for cached
    items and implementing an eviction policy, such as Least Recently Used
    (LRU), to manage memory efficiently.
  </p>
  <p>&nbsp;</p>
</section>
<h2>Rendering @mentions</h2>
<p>
  Our rich text editor implements a sophisticated text rendering method that
  enhances plain text with dynamic features using metadata. The
  <code>renderText</code> function works in three distinct steps:
</p>
<ol>
  <li>
    <strong>Read Text:</strong> The function begins by reading the provided text
    input, which is the base content without any formatting.
  </li>
  <li>
    <strong>Iterate Through Metadata:</strong> The next step is to iterate
    through the metadata array, applying the specified transformations to the
    text. For each piece of metadata, which contains offset and length, the
    function extracts the substring from the text and wraps it with an HTML
    element to apply the desired style or interaction. This could mean wrapping
    the text in a <code>&lt;strong&gt;</code> tag for bold styling, a
    <code>&lt;a&gt;</code> tag for links, or custom elements for mentions and
    hashtags.
  </li>
  <li>
    <strong>Return the Styled Characters:</strong> Finally, the function
    assembles the processed text fragments back into a single string, which
    represents the fully styled text ready to be displayed in the editor or on
    the webpage.
  </li>
</ol>
<pre><code>function renderText(text, metadata) {
  // Initial steps...
  // Styling and interaction application...
  // Return processed text...
}</code></pre>
<p>
  This method provides a seamless and interactive user experience, allowing for
  rich content creation within the editor.
</p>
<article>
  <h2>Edge Case Management for @mentions and #hashtags</h2>
  <section>
    <h3>Rendering Results Popover</h3>
    <p>
      Ensuring the results popover for @mentions and #hashtags appears correctly
      involves two main positioning strategies:
    </p>
    <ul>
      <li>
        <strong>Relative to Parent:</strong> This approach uses
        <code>position: absolute</code> on the results, which is simple and easy
        to implement. However, developers must be mindful of potential
        <code>z-index</code> issues.
      </li>
      <li>
        <strong>React Portals:</strong> Leveraging React Portals can help manage
        overflow and <code>z-index</code> issues by rendering the popover
        outside of the DOM hierarchy. This method requires careful manual
        calculations for positioning.
      </li>
    </ul>
  </section>
  <section>
    <h3>Network Optimization</h3>
    <p>
      To handle network efficiency when users search for mentions or hashtags, a
      combination of debouncing and caching is essential.
    </p>
    <ul>
      <li>
        <strong>Debounce Input:</strong> By implementing a debounce function,
        unnecessary API calls can be minimized, triggering requests only after a
        set idle time after the user has stopped typing.
      </li>
      <li>
        <strong>Caching with TTL:</strong> Utilizing caching mechanisms with
        Time To Live (TTL) settings helps to serve repeated requests swiftly
        without overloading the server.
      </li>
      <li>
        <strong>Normalized Data Store:</strong> A normalized data store can
        ensure efficient memory usage and remove data duplication by storing
        results based on unique identifiers.
      </li>
    </ul>
  </section>
  <section>
    <h3>User Interaction Handling</h3>
    <p>
      Addressing user interactions such as deletions, undos, and new searches is
      critical for a seamless user experience.
    </p>
    <ul>
      <li>
        <strong>Handling Deletions:</strong> When the user hits backspace, the
        editor must intelligently detect if it&#8217;s within the metadata range
        and update the UI accordingly.
      </li>
      <li>
        <strong>Handling Undos:</strong> Keeping a stack of user actions allows
        the editor to easily revert to previous states when the undo action is
        triggered.
      </li>
      <li>
        <strong>Handling New Searches:</strong> The editor must be able to
        handle new searches dynamically, showing relevant suggestions based on
        the latest input.
      </li>
    </ul>
  </section>
  <footer>
    Exploring these edge cases ensures that our implementation of @mentions and
    #hashtags is robust, user-friendly, and efficient in terms of network and
    rendering performance.
  </footer>
  <footer></footer>
</article>
<footer>
  <h2></h2>
  <h2>Conclusion</h2>
  <p>
    Designing a rich text editor that supports @mentions and #hashtags is a
    nuanced task, which involves careful consideration of UI/UX design, network
    efficiency, and robust handling of user interactions. This article has
    delved into several edge cases and presented practical solutions for each,
    including the use of React Portals for UI placement, debouncing, and caching
    strategies for network optimization, and algorithmic approaches for dynamic
    content interaction. As we aim to provide a seamless and intuitive editing
    experience, these considerations are pivotal in building a feature-rich and
    performant application that meets the needs of modern web interactions.
  </p>
</footer>
