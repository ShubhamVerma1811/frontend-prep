<h1>Interface Communication Frontend System Design Interviews</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1698"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42.png"
    alt="Interface Communication For Frontend System Design"
    width="1920"
    height="1080"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42.png          1920w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42-300x169.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42-1024x576.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42-768x432.png   768w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-42-1536x864.png 1536w
    "
    sizes="(max-width: 1920px) 100vw, 1920px"
  />
</p>
<article>
  The “I” in the RADIO framework stands for Interface, which is partially about
  how the front-end system communicates with the backend (interface
  communication) and how it will format its request and response (API layer). 
</article>
<article></article>
<article></article>
<article>
  This section is critical, but it shouldn’t take more than 15 percent of your
  interview time unless the interviewer wants to discuss it in depth.
  Let&#8217;s simplify this section so that the first half is focused on the
  interface layer, and the following article will focus on the API design layer.
</article>
<article>
  <blockquote>
    <p>
      <em
        ><strong
          >Please spend no more than 5% of your interview explaining the
          interface communication layer and 10% on the api layer.</strong
        ></em
      >
    </p>
  </blockquote>
  <p>
    Before diving into API design, determine your protocol for the API layer.
    The right choice depends on the nature of the app and its requirements. For
    example, if you’re building a chat application, real-time, two-way
    communication is key, so WebSockets make sense. If you’re streaming updates
    in one direction, such as an AI chat response, server-sent events (SSE) are
    a good fit. Regular HTTP requests do the job for use cases like a news feed
    or simple data fetches as the user scrolls.
  </p>
  <p>Here’s a table that compares the main protocols you might consider:</p>
  <table>
    <thead>
      <tr>
        <th>Protocol</th>
        <th>Description</th>
        <th>Best Use Case</th>
        <th>Pros</th>
        <th>Cons</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>HTTP (REST)</td>
        <td>Traditional request-response, stateless, one-way</td>
        <td>Fetching data, CRUD apps, news feeds, and most APIs</td>
        <td>Simple, well-supported, cacheable, easy to debug</td>
        <td>No real-time, can be chatty for frequent updates</td>
      </tr>
      <tr>
        <td>Short Polling</td>
        <td>The client frequently requests new data on a timer</td>
        <td>Low-frequency updates, simple notifications</td>
        <td>Easy to implement, no persistent connection</td>
        <td>Wastes bandwidth, latency, and is not efficient at scale</td>
      </tr>
      <tr>
        <td>Long Polling</td>
        <td>
          Client requests data, server holds connection until update or timeout
        </td>
        <td>Near real-time updates, legacy support</td>
        <td>More responsive than short polling, simple fallback</td>
        <td>Can tie up server resources, and is more complex to scale</td>
      </tr>
      <tr>
        <td>Server-Sent Events (SSE)</td>
        <td>
          Server pushes updates to client, client receives in real time
          (one-way)
        </td>
        <td>Live feeds, notifications, streaming responses</td>
        <td>Simple API, built-in reconnect, works over HTTP</td>
        <td>One-way only, not supported in all browsers</td>
      </tr>
      <tr>
        <td>WebSockets</td>
        <td>Full duplex, persistent two-way communication</td>
        <td>Chat, multiplayer games, and collaborative editing</td>
        <td>Real-time, efficient, low-latency</td>
        <td>
          More complex, requires a stateful server, and can be harder to scale
        </td>
      </tr>
      <tr>
        <td>GraphQL</td>
        <td>
          Client defines queries, gets exactly the data needed in one request
        </td>
        <td>Apps with complex or nested data, mobile, SPAs</td>
        <td>Reduces over-fetching, is flexible, and promotes introspection</td>
        <td>Requires schema, learning curve, and can hide complexity</td>
      </tr>
    </tbody>
  </table>
  <p>
    Protocol choice should match your product’s requirements. Real-time needs?
    Think WebSockets. One-way streaming? Try SSE. Standard API data fetching? Go
    with REST or GraphQL. For most standard apps, HTTP REST remains a reliable
    default.
  </p>
  <p>
    You can find a deeper dive for each in this
    <a href="https://frontendlead.com/system-design/web-protocols-cheat-sheet"
      >article</a
    >.
  </p>
</article>
<hr />
<p>
  Next, look into designing the API in frontend system design interviews. You
  might be wondering (probably not), shouldn&#8217;t
  <strong>R.A.D.I.O</strong> have an extra <strong>A</strong>, for API design?
  While you may be right, we don&#8217;t talk about it.
</p>
<p>Now let&#8217;s proceed.</p>
