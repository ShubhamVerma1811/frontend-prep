<h1>Design Chat Application &#8211; Frontend System Design Guide</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-591"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.53.19-AM.png"
    alt=""
    width="492"
    height="360"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.53.19-AM.png         492w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.53.19-AM-300x220.png 300w
    "
    sizes="(max-width: 492px) 100vw, 492px"
  />
</p>
<h2>Requirements</h2>
<h3>Functional</h3>
<p>You provided the following main functional requirements:</p>
<ol>
  <li class="">Real-time sending and receiving of messages across devices.</li>
  <li class="">
    Offline support: Messages sent offline should be stored and then sent when
    the user comes back online.
  </li>
</ol>
<p>Clarifying Questions:</p>
<ol>
  <li class="">
    Is there any authentication required for users?
    <ol type="a">
      <li class="">Assume users are authenticated.</li>
    </ol>
  </li>
  <li class="">
    Do we need features like message read indicators, typing indicators, or
    group chats?
    <ol type="a">
      <li class="">If we have time at the end, right now, out of scope.</li>
    </ol>
  </li>
  <li class="">
    What about media messages, like images, videos, or files?
    <ol type="a">
      <li class="">If we have time at the end, right now, out of scope.</li>
    </ol>
  </li>
  <li class="">
    Is message history preserved indefinitely, or is there some sort of
    retention policy?
    <ol type="a">
      <li class="">We will leave that up to you to follow best practices.</li>
    </ol>
  </li>
  <li class="">
    How should notifications be handled?
    <ol type="a">
      <li class="">Out of scope right now.</li>
    </ol>
  </li>
</ol>
<h3>Non-Functional</h3>
<ol>
  <li class="">
    Observability: Given that every user might send or receive messages multiple
    times a day, and if there are thousands or even millions of users, the log
    volume can be substantial. Depending on the volume, logs can contribute
    significantly to the costs. Consider storing logs selectively or aggregating
    them. Monitoring and alerting should be in place for the chat system&#8217;s
    health and performance metrics.
  </li>
  <li class="">
    Devices: To be clarified. (Assuming web for desktop and mobile as well as
    native mobile apps for iOS and Android.)
  </li>
  <li class="">
    Demographics: Given that it&#8217;s a chat application, it&#8217;s safe to
    assume a global audience unless specified.
  </li>
  <li class="">
    Accessibility: The application should follow web accessibility standards
    like WCAG. Features like screen reader support, high contrast mode, keyboard
    accessibility, etc., should be integrated.
  </li>
  <li class="">
    Performance: Users expect real-time applications to be fast and responsive.
    Latency should be minimized, especially in message delivery.
  </li>
</ol>
<h2>High-Level Architecture Design</h2>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-592"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.51.59-AM.png"
    alt=""
    width="808"
    height="675"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.51.59-AM.png         808w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.51.59-AM-300x251.png 300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-10-13-at-9.51.59-AM-768x642.png 768w
    "
    sizes="(max-width: 808px) 100vw, 808px"
  />
</p>
<h3>MVC Model</h3>
<p>Model: Represents the data structures and the business logic.</p>
<ul>
  <li class="">
    User Data: Includes user credentials, JWT tokens, and user profile data.
  </li>
  <li class="">
    Chat Data: Conversations and messages associated with each user.
  </li>
</ul>
<p>View: Represents the UI of the application.</p>
<ul>
  <li class="">Conversations Screen: List of ongoing conversations.</li>
  <li class="">
    Conversation Detail Screen: Detailed view of a single conversation with
    messages.
  </li>
</ul>
<p>
  Controller: Manages the data flow into the model object and updates the view
  whenever data changes.
</p>
<ul>
  <li class="">Handles user input, server responses, and data persistence.</li>
</ul>
<h3>Communication with the Server</h3>
<p>
  We&#8217;d primarily be using WebSockets for real-time bidirectional
  communication. WebSockets are chosen for instant message sending/receiving
  without the overhead of repeatedly establishing connections, which would be
  the case in HTTP long-polling.
</p>
<p><strong>Data Flow:</strong></p>
<ol>
  <li class="">
    User logs in, and after successful authentication, receives a JWT.
  </li>
  <li class="">
    The client establishes a WebSocket connection using the JWT for
    authentication.
  </li>
  <li class="">
    For offline messages, the client stores them locally. Once back online, the
    client sends these messages over the WebSocket.
  </li>
  <li class="">
    The server processes the incoming messages, persists them, and broadcasts to
    the intended recipient(s).
  </li>
</ol>
<p>
  On the Conversations Screen, when a new message arrives, the respective
  conversation bubbles up. On the Conversation Detail Screen, new messages
  appear in real-time.
</p>
<ol>
  <li class="">
    A &#8220;User&#8221; box sends an &#8220;Authenticate&#8221; action to a
    &#8220;Server&#8221; box.
  </li>
  <li class="">
    The &#8220;Server&#8221; box responds with &#8220;JWT.&#8221;
  </li>
  <li class="">
    The &#8220;User&#8221; box initiates &#8220;WebSocket Connection&#8221; to
    the &#8220;Server&#8221; box, which is authenticated using the JWT.
  </li>
  <li class="">
    Bi-directional arrows represent ongoing &#8220;Message Exchange&#8221;
    between the &#8220;User&#8221; box and the &#8220;Server&#8221; box over the
    WebSocket.
  </li>
</ol>
<h3>Device Support</h3>
<p>Given the requirements and the usual expectations for such applications:</p>
<ul>
  <li class="">
    Web: Progressive Web Application (PWA) to support both desktop and mobile
    browsers. PWAs can also provide offline capabilities using service workers.
  </li>
  <li class="">
    Mobile: Native apps for iOS and Android. They provide better integration
    with device capabilities and can utilize local storage for offline message
    support.
  </li>
</ul>
<p>
  The high-level architecture gives an overview of the structure and data flow
  of our chat application.
</p>
<h2>Handling Infinite Scrolling in our API</h2>
<h3>Offset-based Pagination:</h3>
<ul>
  <li class="">Uses a numeric offset to skip a fixed number of records.</li>
  <li class="">
    Can be inefficient for large datasets because databases might scan from the
    start of the table to the offset.
  </li>
  <li class="">
    In a real-time chat scenario, if new messages are inserted at the start
    (newer messages), the offset can skip or duplicate messages, leading to a
    poor user experience.
  </li>
</ul>
<h3>Cursor-based Pagination:</h3>
<ul>
  <li class="">
    Uses a &#8220;cursor&#8221; (often a unique ID or a timestamp) to navigate
    through records.
  </li>
  <li class="">
    More efficient for databases since they can jump directly to a record.
  </li>
  <li class="">
    Handles real-time data more gracefully. Even if new messages are added,
    using a unique ID or timestamp as a cursor ensures users won&#8217;t see
    duplicates or miss messages.
  </li>
  <li class="">
    Well-suited for frequently updated datasets, like real-time chat messages.
  </li>
</ul>
<p>
  Given the advantages of cursor-based pagination, especially in the context of
  a real-time chat application, I&#8217;d recommend using it.
</p>
<p><strong>Intersection Observer vs Scroll Based</strong></p>
<p>
  We should use intersection observer due to it&#8217;s performant nature (not
  running on the main thread) vs using window.scroll and having to debounce and
  customize it.
</p>
<h2>API Design</h2>
<p>
  Given the real-time nature of the application, the primary communication will
  be over WebSockets. However, we&#8217;ll also need some HTTP-based endpoints
  for the initial setup, like authentication.
</p>
<h3>Protocol</h3>
<ul>
  <li>
    HTTP/HTTPS: For authentication and initial setup. HTTPS ensures encrypted
    and secure data transfer.
  </li>
  <li>
    WebSockets (over TLS for encryption, <code>wss</code>): For real-time
    bidirectional communication between the client and server.
  </li>
</ul>
<h3><strong>Authentication</strong></h3>
<p>To log a user in and receive a JWT.</p>
<p>Endpoint:</p>
<pre><code>/api/auth/login</code></pre>
<p>Method:</p>
<pre><code>POST</code></pre>
<p>Request:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>{ "username": "exampleUser", "password": "examplePass" } </code></pre>
<p>Response:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>{ "token": "jwtTokenStringHere", "user": { "id": "user123", "name": "Alice" } } </code></pre>
<h3><strong>Get Conversations</strong></h3>
<p>Retrieve a list of conversations for a user.</p>
<p>Endpoint:</p>
<pre><code>/api/conversations</code><code>?afterId=cnv123&amp;limit=10</code></pre>
<p>Method:</p>
<pre><code>GET</code></pre>
<p>Headers:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>Authorization: Bearer jwtTokenStringHere </code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
    "conversations": [
        {
            "id": "conv1",
            "lastMessage": {
                "id": "msg567",
                "content": "How are you?",
                "timestamp": 1676543289
            },
            "participants": ["user123", "user456"]
        },
        // ... other conversations
    ]
}</code></pre>
<h3><strong>Get Messages for a Conversation</strong></h3>
<p>Retrieve messages for a specific conversation.</p>
<p>Endpoint:</p>
<pre><code>/api/conversations/:conversationId/messages?afterId=msg123&amp;limit=10</code></pre>
<p>Method:</p>
<pre><code>GET</code></pre>
<p>Headers:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>Authorization: Bearer jwtTokenStringHere</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
    "messages": [
        {
            "id": "msg124",
            "content": "Hey!",
            "senderId": "user456",
            "timestamp": 1676543290
        },
        // ... other messages
    ]
}</code></pre>
<h3><strong>Send a Message</strong></h3>
<p>Send a message within a conversation.</p>
<p>Endpoint:</p>
<pre><code>/api/conversations/:conversationId/messages</code></pre>
<p>Method:</p>
<pre><code>POST</code></pre>
<p>Headers:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>Authorization: Bearer jwtTokenStringHere </code></pre>
<p>Request:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>{ "content": "Hi there!" } </code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
    "message": {
        "id": "msg789",
        "content": "Hi there!",
        "senderId": "user123",
        "timestamp": 1676543390
    }
}</code></pre>
<h3><strong>Update Message Status</strong> (for offline handling)</h3>
<p>
  When the client comes back online and wants to update the status of messages
  that were sent offline.
</p>
<p>Endpoint: <code>/api/messages/:messageId/status</code></p>
<p>Method: <code>PUT</code></p>
<p>Headers:</p>
<pre
  class="ql-syntax"
  spellcheck="false"
><code>Authorization: Bearer jwtTokenStringHere </code></pre>
<p><br class="softbreak" />Request:</p>
<pre class="ql-syntax" spellcheck="false"><code>{ "isSent": true } </code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
    "message": {
        "id": "msg789",
        "isSent": true
    }
}</code></pre>
<h2>Client Data Model</h2>
<h3>Data Types</h3>
<pre class="ql-syntax" spellcheck="false"><code>interface User {
    id: string;
    name: string; // This can include other fields like avatar, status, etc.
}

interface Message {
    id: string;
    content: string;
    senderId: string; // Reference to User's ID
    timestamp: number; // POSIX timestamp for message time
    isSent: boolean;   // Indicates if the message was sent (useful for offline scenarios)
}

interface Conversation {
    id: string;
    lastMessageId: string; // ID of the last message in the conversation for easy retrieval and ordering
    participantIds: string[]; // IDs of the participants
}</code></pre>

<h3>Client Store</h3>
<pre class="ql-syntax" spellcheck="false"><code>interface ClientStore {
    users: { [id: string]: User };               // Dictionary of users
    messages: { [id: string]: Message };        // Dictionary of messages
    conversations: { [id: string]: Conversation }; // Dictionary of conversations
    currentConversationId: string | null;       // The ID of the currently selected conversation
}</code></pre>
<p>Explained:</p>
<ul>
  <li>
    <code>users</code>: A dictionary of all users the client knows about. Each
    user can be fetched using their <code>id</code>.
  </li>
  <li>
    <code>messages</code>: All messages are stored in a dictionary. This makes
    it easy to fetch a specific message and also helps in ensuring each message
    is stored only once, even if it&#8217;s part of multiple conversations.
  </li>
  <li>
    <code>conversations</code>: Conversations are stored in a dictionary as
    well. For each conversation, we store participant IDs and the ID of the last
    message. This helps in ordering conversations based on the latest message.
  </li>
  <li>
    <code>currentConversationId</code>: This field helps in tracking which
    conversation is currently being viewed or acted upon by the user.
  </li>
</ul>
<p>
  The above model makes it easy to fetch specific entities (users, messages,
  conversations) by their IDs, ensuring efficient updates and minimal
  redundancy. Also, using TypeScript provides the added advantage of
  type-safety, making it easier to manage and less prone to errors.
</p>
<h2>Optimizations</h2>
<h4>Virtualization</h4>
<p>
  Given that a user can have many messages in a conversation, rendering all of
  them can affect performance. Virtualization techniques, like using a library
  such as <code>react-virtualized</code> or <code>react-window</code>, allow us
  to render only the messages visible in the viewport, boosting performance.
  This is particularly useful for the chat messages view.
</p>
<p>Trade-offs:</p>
<ul>
  <li>
    Pros: Reduced DOM nodes and improved performance, especially for long chat
    histories.
  </li>
  <li>
    Cons: Complexity in implementation, especially with dynamic message heights.
    Scroll behavior might feel a bit different from native scrolling for some
    users.
  </li>
</ul>
<h3>Debouncing/Throttle</h3>
<p>
  To improve the user experience and reduce the number of unnecessary
  operations:
</p>
<ul>
  <li>
    Debounce the search or filter operations in the conversation list. If a user
    is quickly typing in a search bar to find a specific conversation, you want
    to wait until they&#8217;ve stopped typing for a brief moment before
    executing the search.
  </li>
  <li>
    Throttle real-time updates to the UI. If many messages are coming in rapid
    succession, you might choose to batch these updates slightly, so the UI
    isn&#8217;t constantly re-rendering.
  </li>
</ul>
<p>Trade-offs:</p>
<ul>
  <li>
    Pros: Reduces the number of operations, API calls, or renders, improving
    efficiency.
  </li>
  <li>
    Cons: Might introduce a tiny lag in UI updates (especially with debouncing),
    but this is generally acceptable for the improved efficiency.
  </li>
</ul>
<h3>Caching</h3>
<p>
  Storing frequently accessed data locally (like recent conversations or
  messages) can vastly improve performance. Tools like
  <code>IndexedDB</code> can be used for this purpose, especially considering
  the offline support requirement.
</p>
<p>Trade-offs:</p>
<ul>
  <li>
    Pros: Rapid data retrieval, reduced API calls, and improved offline
    experience.
  </li>
  <li>
    Cons: Need to manage cache invalidation, and there&#8217;s potential for
    displaying stale data if not managed correctly.
  </li>
</ul>
<h3>Normalization</h3>
<p>
  Using normalized vs. non-normalized data for caching largely depends on the
  specific use case and the operations you perform on the data. Let&#8217;s
  first discuss the pros and cons of each approach before diving into the code
  examples:
</p>
<ol>
  <li class="ql-indent-1">
    Advantages:Reduces redundancy: Only one copy of each piece of data.
  </li>
  <li class="ql-indent-1">
    Ensures consistency: When an item is updated, there&#8217;s only one place
    to update, so all references stay consistent.
  </li>
  <li class="ql-indent-1">
    Can be more efficient in storage when there&#8217;s a lot of redundant data.
  </li>
  <li class="ql-indent-1">
    Disadvantages:Reading operations might be a bit complex because you&#8217;d
    need to reconstruct data from various references.
  </li>
</ol>
<h3>Non-Normalized</h3>
<ol>
  <li class="ql-indent-1">
    Advantages:Simplifies read operations: You get the entire structure as-is,
    without needing to reconstruct it.
  </li>
  <li class="ql-indent-1">
    Faster for use cases where reading is more frequent than writing.
  </li>
  <li class="ql-indent-1">
    Disadvantages:Redundant data can lead to inconsistencies. If data is updated
    in one place, it might still be outdated in another.
  </li>
  <li class="ql-indent-1">Might consume more storage.</li>
</ol>
<p>
  For a chat application, given the frequency of reading operations (e.g.,
  displaying messages) and the potential complexity of chat structures (nested
  messages, references to users, etc.), normalized data can be a good choice for
  cache.
</p>
<p>
  Let&#8217;s consider a simple scenario where you want to store conversations
  with messages:
</p>
<p><strong>Non-Normalized:</strong></p>
<pre class="ql-syntax" spellcheck="false"><code>interface User {
    id: string;
    name: string;
}

interface Message {
id: string;
content: string;
sender: User;
}

interface Conversation {
id: string;
participants: User[];
messages: Message[];
}

// Example of non-normalized data:
const conversation: Conversation = {
id: "conv1",
participants: [
{ id: "user1", name: "Alice" },
{ id: "user2", name: "Bob" }
],
messages: [
{ id: "msg1", content: "Hi Bob!", sender: { id: "user1", name: "Alice" } },
{ id: "msg2", content: "Hey Alice!", sender: { id: "user2", name: "Bob" } }
]
};</code></pre>

<p><strong>Normalized Data Example</strong></p>
<pre class="ql-syntax" spellcheck="false"><code>interface User {
    id: string;
    name: string;
}

interface Message {
    id: string;
    content: string;
    senderId: string; // Reference to User
}

interface Conversation {
    id: string;
    participantIds: string[]; // Reference to Users
    messageIds: string[];     // Reference to Messages
}

const users: { [key: string]: User } = {
    "user1": { id: "user1", name: "Alice" },
    "user2": { id: "user2", name: "Bob" }
};

const messages: { [key: string]: Message } = {
    "msg1": { id: "msg1", content: "Hi Bob!", senderId: "user1" },
    "msg2": { id: "msg2", content: "Hey Alice!", senderId: "user2" }
};

const conversation: Conversation = {
    id: "conv1",
    participantIds: ["user1", "user2"],
    messageIds: ["msg1", "msg2"]
};</code></pre>

<p>
  In the non-normalized example, all data is directly embedded in the
  <code>Conversation</code> structure. In the normalized version, we have
  separate dictionaries (or maps) for users and messages, and we reference them
  by IDs in the conversation.
</p>
<p>
  For the chat application, the normalized approach can help in ensuring that
  when a user&#8217;s details (e.g., name) change, they&#8217;re updated
  consistently across all conversations and messages without redundancy.
</p>
