<h1>Design Airbnb &#8211; Frontend System Design</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1717"
    src="https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45.png"
    alt="Design Airbnb - Frontend System Design"
    width="1920"
    height="1080"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45.png          1920w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45-300x169.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45-1024x576.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45-768x432.png   768w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/FrontendLead-45-1536x864.png 1536w
    "
    sizes="(max-width: 1920px) 100vw, 1920px"
  />
</p>
<h2>Problem Statement</h2>
<blockquote>
  <p>Build the frontend for a hotel booking website.</p>
  <p>Requirements:</p>
  <ul>
    <li>Display a grid of hotels or houses available for booking</li>
    <li>
      Each grid tile should show a slideshow of images (image carousel), the
      property title, and the price per night
    </li>
    <li>
      The layout should be fully responsive and look good on both desktop and
      mobile devices
    </li>
    <li>
      Users should be able to scroll within each property’s images to view a
      slideshow
    </li>
  </ul>
  <p>
    Describe your approach to component structure, implementing the image
    carousel, fetching data for hotels and images, and any optimizations you’d
    consider for performance and user experience.
  </p>
</blockquote>
<hr />
<h2>Clarifying Questions</h2>
<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Question</th>
      <th>Interviewer’s Answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Where is the hotel data coming from? Can you describe the API?</td>
      <td>Please design the API.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>How many images per property? Should we optimize for many or few?</td>
      <td>You should design that for optimal performance.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>
        Should the image carousel auto-play, or only allow manual scrolling?
      </td>
      <td>Manual.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>
        Any requirements for accessibility? (e.g., keyboard navigation, ARIA)
      </td>
      <td>Yes, keep it accessible.</td>
    </tr>
    <tr>
      <td>5</td>
      <td>
        Should the grid use pagination, infinite scrolling, or show all at once?
      </td>
      <td>Yes, pagination.</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Should users be able to filter or sort hotel listings?</td>
      <td>No need for filters right now.</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Preferred technology stack or CSS framework?</td>
      <td>Up to you, but let&#8217;s focus on React.</td>
    </tr>
    <tr>
      <td>8</td>
      <td>Any performance or scalability constraints?</td>
      <td>Yes, please consider performance and scale.</td>
    </tr>
    <tr>
      <td>9</td>
      <td>Should we show loading or error states?</td>
      <td>Graceful loading is always good.</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Should we support localization/multi-currency for price display?</td>
      <td>Yes, you can talk about localization.</td>
    </tr>
    <tr>
      <td>11</td>
      <td>Any offline support needed?</td>
      <td>Out of scope.</td>
    </tr>
  </tbody>
</table>
<hr />
<h2>Requirements</h2>
<h3>Functional Requirements</h3>
<ul>
  <li>Display a paginated, responsive grid of hotel/house listings</li>
  <li>
    Each tile includes a manual image carousel, property title, and price per
    night
  </li>
  <li>
    Images for each property should be viewable by scrolling/swiping within the
    tile
  </li>
  <li>Data is fetched from an API you design</li>
  <li>Site is accessible (keyboard navigation, ARIA labels, etc.)</li>
  <li>Graceful loading states and error handling for data fetching</li>
  <li>Price supports localization/multi-currency</li>
</ul>
<h3>Non-Functional Requirements</h3>
<ul>
  <li>Fast load times and smooth scrolling, even with many properties</li>
  <li>Scales to support large numbers of users and listings</li>
  <li>Fully responsive design (works well on desktop, tablet, and mobile)</li>
  <li>Designed with accessibility standards (WCAG) in mind</li>
  <li>
    Good performance: optimized image loading, lazy loading for images/carousels
  </li>
  <li>SEO-friendly markup where applicable</li>
  <li>No offline support required</li>
</ul>
<h3>Napkin Math (Estimations)</h3>
<p>Assume a medium-sized site for initial design:</p>
<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Estimate / Calculation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Daily Active Users</td>
      <td>100,000 users/day</td>
    </tr>
    <tr>
      <td>Listings per Page</td>
      <td>20 (typical grid pagination size)</td>
    </tr>
    <tr>
      <td>Avg. Images/Listing</td>
      <td>5</td>
    </tr>
    <tr>
      <td>Total Daily Pageviews</td>
      <td>500,000 pageviews/day (average five pages/user)</td>
    </tr>
    <tr>
      <td>Images Loaded/Day</td>
      <td>500,000 pages × 20 listings × 5 images = 50,000,000</td>
    </tr>
    <tr>
      <td>Peak QPS</td>
      <td>(500,000 ÷ 24 ÷ 3600) × 2 ≈ 12 requests/sec (per API)</td>
    </tr>
  </tbody>
</table>
<p>
  <strong>API throughput:</strong> At peak, expect to serve up to ~12 grid pages
  per second (likely higher with bursts; design for 5x overhead, so aim for 60
  QPS).
</p>
<hr />
<h2>Architecture / Component Design</h2>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1715"
    src="https://api.frontendlead.com/wp-content/uploads/2024/06/Screenshot-2025-05-19-at-8.40.50-AM.png"
    alt="Airbnb Frontend System Design Architecture"
    width="1268"
    height="1071"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/06/Screenshot-2025-05-19-at-8.40.50-AM.png          1268w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/Screenshot-2025-05-19-at-8.40.50-AM-300x253.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/Screenshot-2025-05-19-at-8.40.50-AM-1024x865.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/06/Screenshot-2025-05-19-at-8.40.50-AM-768x649.png   768w
    "
    sizes="(max-width: 1268px) 100vw, 1268px"
  />
</p>
<h3>User, Router, and Routing</h3>
<p>
  Everything starts when the user enters the app. At its core,
  <strong>React Router</strong> handles navigation between pages, such as the
  main bookings list and, in the future, more routes like a property details
  page or user account section. Right now, the router primarily directs users to
  the bookings grid. Suppose you need to support more routes down the line. In
  that case, React Router’s configuration can be easily extended by adding new
  route definitions, and the router will handle navigation between them without
  any significant architectural changes.
</p>
<p>
  Routing like this keeps the UI fast and modern. Users can move between pages
  without waiting for full reloads, which feels much smoother and more like a
  native app.
</p>
<hr />
<h3>SSR vs CSR (Server-Side Rendering vs Client-Side Rendering)</h3>
<p>
  For this hotel booking frontend, it’s essential to consider how and where our
  pages are rendered.
</p>
<ul>
  <li>
    <strong>Server-Side Rendering (SSR):</strong> The HTML for each page is
    generated on the server and sent to the client. This means the first load is
    fast, SEO is better, and users see content more quickly, even before all
    JavaScript is loaded.
  </li>
  <li>
    <strong>Client-Side Rendering (CSR):</strong> The server sends a minimal
    HTML shell, and the browser downloads JavaScript, fetches data, and renders
    everything on the client. This can be great for fast, app-like navigation
    and complex interactions after the initial load.
  </li>
</ul>
<p>
  A standard, scalable approach is
  <strong>SSR for the initial page load</strong> (so users and search engines
  get content quickly), and <strong>CSR for all interactions</strong> (like
  clicking on a tile to view more images, paginating, or loading more listings).
</p>
<p>Here’s a table comparing SSR and CSR for our use case:</p>
<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>SSR (Server-Side Rendering)</th>
      <th>CSR (Client-Side Rendering)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Initial load speed</td>
      <td>Fast, since the content is pre-rendered</td>
      <td>Slower, must fetch and render on the client</td>
    </tr>
    <tr>
      <td>SEO</td>
      <td>Excellent, full HTML sent to the crawler</td>
      <td>Poor, unless extra work for pre-render</td>
    </tr>
    <tr>
      <td>Interactivity</td>
      <td>Needs hydration, then fast</td>
      <td>Very fast after JS loads</td>
    </tr>
    <tr>
      <td>User experience</td>
      <td>Content visible quickly</td>
      <td>A blank or loading spinner at first</td>
    </tr>
    <tr>
      <td>Complexity</td>
      <td>Requires server setup (e.g., Next.js)</td>
      <td>Simpler static hosting is possible</td>
    </tr>
    <tr>
      <td>Best for&#8230;</td>
      <td>Landing/search pages, listings</td>
      <td>Deeply interactive UIs, dashboards</td>
    </tr>
  </tbody>
</table>
<p>
  For this project, SSR will make the booking grid fast and SEO-friendly, while
  CSR can handle all the snappy UI interactions after the first load.
</p>
<hr />
<h3>State Management and Data Flow</h3>
<p>
  State management is a vast topic in frontend architecture, especially for an
  app like this. The right choice depends on how complex the state gets, how
  many places need to read or update it, and what kind of performance you need
  as you scale.
</p>
<h4>Options for State Management</h4>
<ul>
  <li>
    <strong>useState</strong><br />
    The simplest state hook in React is great for truly local state (like input
    fields or the current image index in a tile). It&#8217;s not ideal for
    global app data like the list of hotels or pagination since you’d have to
    “lift” state up multiple levels, which gets messy fast.
  </li>
  <li>
    <strong>useContext</strong><br />
    React’s Context API lets you provide and consume state anywhere in the
    component tree. It’s solid for global, app-level states like hotel lists,
    pagination info, or loading status. It’s lightweight and doesn’t require
    external libraries, so keep your bundle size small and avoid unnecessary
    performance overhead. useContext is a strong choice for this project because
    we don’t have complex, deeply nested state or huge cross-component updates.
  </li>
  <li>
    <strong>Redux</strong><br />
    Redux is super popular for large apps with many moving parts and strict
    state transition rules. It’s powerful, but it comes with a cost: extra
    boilerplate, a learning curve, and sometimes performance hits due to how
    Redux triggers updates across the app. Redux is overkill for a focused
    booking site like this and may slow things down if you’re not careful about
    structuring selectors and reducers.
  </li>
  <li>
    <strong>Zustand, Recoil, Jotai, etc.</strong><br />
    There’s a wave of modern, minimal state management libraries that solve pain
    points in Redux and Context. Zustand, for example, gives you simple state
    containers with good performance and less boilerplate. If you ever outgrow
    Context or want fancier state control, these are worth exploring. For now,
    though, Context will keep things simple and readable.
  </li>
</ul>
<h4>Scoped State per Tile</h4>
<p>
  Beyond the global state, you often need to be “scoped” or local state for
  components like image slideshows or loading status per hotel card. For
  instance, if a user scrolls through images in one tile, you don’t want to
  re-render all tiles or blow away their position just because new data comes
  in. The solution is to use local state (with useState) inside each tile for
  things like the active image, loading animations, etc.
</p>
<p>
  When the app fetches new data for a page, you also want to avoid blindly
  replacing everything and causing UI jumps. You can implement a diff check; if
  the incoming data for a hotel hasn’t changed, leave the tile alone. Only
  update those with new info (like price changes, new images, etc.). This is
  both a performance win and a better user experience.
</p>
<h4>Why useContext for This Project?</h4>
<p>
  For this app, <strong>React Context</strong> strikes the right balance between
  simplicity, performance, and scalability:
</p>
<ul>
  <li>
    It keeps the global state in one place and is easily accessible across the
    app.
  </li>
  <li>It avoids Redux’s overhead and complexity.</li>
  <li>
    It works well with the View Model pattern, allowing you to separate business
    logic and data transformation from your UI components.
  </li>
  <li>
    You can mix it with local state, especially for interactive components like
    carousels.
  </li>
</ul>
<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Pros</th>
      <th>Cons</th>
      <th>Best Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>useState</td>
      <td>Simple, built-in, great for local state</td>
      <td>Not scalable for global state</td>
      <td>Image index in a tile</td>
    </tr>
    <tr>
      <td>useContext</td>
      <td>Global state, minimal boilerplate</td>
      <td>Unintended re-renders for large trees</td>
      <td>Hotel list, pagination</td>
    </tr>
    <tr>
      <td>Redux</td>
      <td>Powerful, time-travel/debugging</td>
      <td>Boilerplate, performance cost</td>
      <td>Huge, complex apps</td>
    </tr>
    <tr>
      <td>Zustand/etc.</td>
      <td>Simple, fast, modern API</td>
      <td>Less standard, another dependency</td>
      <td>Growing apps, fine control</td>
    </tr>
  </tbody>
</table>
<p>
  Overall, go with <strong>useContext</strong> for the main store, and use
  <strong>local state</strong> for per-tile interactions. If the app grows into
  something more complex, migrating to a modern state lib is always an option,
  but starting simple is almost always the best move.
</p>
<hr />
<h3>Bookings List Component Structure</h3>
<p>
  The <strong>BookingsListContainer</strong> is the hotel grid page&#8217;s main
  “container” component. It calls <code>useViewModel()</code> to get the current
  data. Inside, it renders a <strong>BookingsListContainerView</strong>, which
  maps over hotel data and renders a <strong>BookingsList</strong>.
</p>
<p>
  Each hotel/house gets its <strong>BookingsCard</strong>, which shows the
  title, price, and image slideshow. The
  <strong>ImageSlideShow</strong> component handles scrolling/swiping through
  images within each tile, keeping things interactive and visually appealing.
</p>
<p>The component structure looks like:</p>
<pre><code>
&lt;BookingsListContainer&gt;
  &lt;BookingsListContainerView&gt;
    &lt;BookingsList&gt;
      &lt;BookingsCard&gt;
        &lt;ImageSlideShow /&gt;
      &lt;/BookingsCard&gt;
    &lt;/BookingsList&gt;
  &lt;/BookingsListContainerView&gt;
&lt;/BookingsListContainer&gt;
</code></pre>
<p>
  The core of this UI is a series of reusable, focused components that build up
  the hotel grid in a predictable, scalable way. Each layer has a clear
  responsibility, and the structure makes testing, extending, and keeping your
  code clean easy.
</p>
<hr />
<h4>BookingsListContainer</h4>
<p>
  This is the “smart” container at the top of the grid page. It handles data
  flow and passes everything down to child components. It calls
  <code>useViewModel()</code> to get the latest state (hotel list, loading
  status, pagination, etc.), and it might trigger data fetching when you hit a
  new page. BookingsListContainer doesn’t worry about layout details or how
  hotels are rendered; it handles the data and coordination.
</p>
<h4>BookingsListContainerView</h4>
<p>
  This main “view” layer handles conditional rendering based on state. For
  example, depending on the situation, it can display a loading spinner, an
  error message, or the BookingsList itself. This keeps business logic and UI
  state (like loading or error states) out of your main grid component, making
  everything cleaner.
</p>
<ul>
  <li>Shows a loading indicator while data is being fetched</li>
  <li>Renders an error message if there’s a fetch problem</li>
  <li>Otherwise, renders the BookingsList with actual hotel data</li>
</ul>
<h4>BookingsList</h4>
<p>
  This component takes an array of hotel/property objects and maps over them to
  render a grid. You can easily style it with CSS Grid or Flexbox for a
  responsive layout. This component doesn’t know about pagination or API
  fetching, just how to lay out several hotel cards.
</p>
<ul>
  <li>Handles the visual grid</li>
  <li>Keeps hotel tiles consistent in size and alignment</li>
  <li>Renders one BookingsCard per hotel</li>
</ul>
<h4>BookingsCard</h4>
<p>
  The BookingsCard is responsible for each hotel’s tile. It receives props like
  the hotel title, price, and image array. All presentation logic for a single
  hotel goes here. This is also where you can integrate click handlers, hover
  states, or even “favorite” buttons in the future.
</p>
<ul>
  <li>Renders the title and price</li>
  <li>Hosts the ImageSlideShow for the property</li>
  <li>Handles any per-tile local state (like current image index)</li>
</ul>
<h4>ImageSlideShow</h4>
<p>
  This interactive piece lets users scroll or swipe through images for each
  hotel/house. It should be accessible (keyboard navigable, screen-reader
  friendly), touch-friendly for mobile, and lightweight so that you don’t load
  all images simultaneously unless needed (think lazy loading or prefetching the
  next/previous image).
</p>
<ul>
  <li>Accepts an array of image URLs</li>
  <li>Handles manual navigation (left/right arrows, swipe, or scroll)</li>
  <li>Maintains local state for the current image index</li>
  <li>Optimizes image loading for performance</li>
</ul>
<h4>Component Relationship Table</h4>
<table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Responsibility</th>
      <th>Receives Data From</th>
      <th>Passes Data To</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BookingsListContainer</td>
      <td>Fetches/holds state, calls useViewModel</td>
      <td>useViewModel</td>
      <td>BookingsListContainerView</td>
    </tr>
    <tr>
      <td>BookingsListContainerView</td>
      <td>Handles loading/error/success display</td>
      <td>BookingsListContainer</td>
      <td>BookingsList</td>
    </tr>
    <tr>
      <td>BookingsList</td>
      <td>Maps hotels into a visual grid</td>
      <td>BookingsListContainerView</td>
      <td>BookingsCard</td>
    </tr>
    <tr>
      <td>BookingsCard</td>
      <td>Displays hotel info and image slideshow</td>
      <td>BookingsList</td>
      <td>ImageSlideShow</td>
    </tr>
    <tr>
      <td>ImageSlideShow</td>
      <td>Renders and manages a slideshow for property images</td>
      <td>BookingsCard</td>
      <td>(internal, manages itself)</td>
    </tr>
  </tbody>
</table>
<p>
  This approach separates data logic, state, and UI, making everything more
  maintainable. You can drop in new features, tweak layouts, or change the data
  flow without refactoring your entire app. If you need to add modals, tooltips,
  or even A/B test a new tile design, this structure makes those changes
  painless.
</p>
<hr />
<h3>Networking and Data Fetching</h3>
<p>
  A <strong>Network Manager</strong> handles all API communication (fetching the
  hotel list, handling pagination, etc.). Instead of components making API calls
  directly, they go through the Network Manager, which can handle retries,
  caching, and logging out of the box.
</p>
<p>
  The Network Manager talks to a <strong>blackbox server</strong> (the API
  backend you’ll design), grabs the latest hotel data, and pipes it into the
  Store/View Model for the UI.
</p>
<hr />
<h3>Image Management and Caching</h3>
<p>
  A key performance area is image loading. The <strong>Img Manager</strong> is
  responsible for fetching and displaying images, so the UI isn’t bogged down by
  network latency. An Image Cache sits between the Img Manager and the network
  to provide fast image loads and reduce redundant network traffic. This caches
  recently viewed images in memory or IndexedDB, so images load instantly if a
  user scrolls back or reloads.
</p>
<p>
  There’s also an <strong>image service</strong>, which you can use as the
  gateway to your image CDN or asset pipeline. The Img Manager requests images
  from the Image Service, which can handle transformations, resizing, and format
  negotiation.
</p>
<p>A basic image flow:</p>
<ol>
  <li>User scrolls to a new hotel tile.</li>
  <li>Img Manager checks the image cache.</li>
  <li>
    If cached, serve immediately. If not, fetch from the Image Service, then
    cache it.
  </li>
</ol>
<hr />
<h3>Component and Data Relationships (Table)</h3>
<p>Here’s a quick table summarizing how pieces talk to each other:</p>
<table>
  <thead>
    <tr>
      <th>Layer/Component</th>
      <th>Role</th>
      <th>Talks To</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>React Router</td>
      <td>Handles navigation/routing</td>
      <td>User, BookingsListContainer</td>
    </tr>
    <tr>
      <td>BookingsListContainer</td>
      <td>Entry point for the hotel list grid</td>
      <td>View Model, UI components</td>
    </tr>
    <tr>
      <td>View Model</td>
      <td>Business logic/data transformation</td>
      <td>Store, Network Manager, UI</td>
    </tr>
    <tr>
      <td>Store (useContext)</td>
      <td>Holds global app state</td>
      <td>View Model</td>
    </tr>
    <tr>
      <td>Network Manager</td>
      <td>Handles API/data fetching</td>
      <td>View Model, Server</td>
    </tr>
    <tr>
      <td>Img Manager</td>
      <td>Handles image fetch/display</td>
      <td>Image Cache, Image Service</td>
    </tr>
    <tr>
      <td>Image Cache</td>
      <td>Speeds up repeat image loads</td>
      <td>Img Manager</td>
    </tr>
    <tr>
      <td>Image Service</td>
      <td>Backend for image assets</td>
      <td>Img Manager</td>
    </tr>
    <tr>
      <td>BookingsCard, ImageSlideShow</td>
      <td>UI for each hotel/property</td>
      <td>BookingsListContainer</td>
    </tr>
  </tbody>
</table>
<hr />
<h3>Scalability and Extensibility</h3>
<p>
  This setup is designed for scale. Network and image logic are centralized so
  you can swap in more advanced caching, logging, or prefetching strategies
  later. The View Model means business logic doesn’t leak into the UI, keeping
  components easy to test and refactor.
</p>
<p>
  If you want to add infinite scroll, filters, or favorites, expand the View
  Model and Store, and most of the UI can stay unchanged. Accessibility is also
  easier to enforce, since the ImageSlideShow and Cards can be built with
  semantic markup and ARIA attributes up front.
</p>
<hr />
<h2>API Design</h2>
<p>
  The API will use <strong>RESTful design principles</strong> over <strong
    >HTTPS</strong
  >
  for our hotel booking app to ensure that all data sent between client and
  server is secure and standard. All endpoints return JSON. REST is familiar to
  front-end developers and works well with frameworks like React, so it’s a
  natural fit.
</p>
<h3>Authentication &amp; Headers</h3>
<p>
  We require all API requests to include an
  <code>Authorization: Bearer &lt;token&gt;</code> header for authenticated
  endpoints. Public endpoints, such as hotel listings, can be accessed without
  authentication, but user-specific or booking actions would require a valid
  token. For localization and currency, clients can send a
  <code>Accept-Language</code> or <code>X-Currency</code> header.
</p>
<ul>
  <li>
    <strong>Authorization:</strong> Bearer token for user auth (JWT or similar)
  </li>
  <li>
    <strong>Accept-Language:</strong> e.g., <code>en-US</code> for localization
  </li>
  <li><strong>X-Currency:</strong> e.g., <code>USD</code>, <code>EUR</code></li>
</ul>
<h3>Pagination: Page-Based vs Cursor-Based</h3>
<p>There are two main styles for paginating API results:</p>
<ul>
  <li>
    <strong>Page-Based:</strong> Uses page numbers
    (<code>page=1&amp;pageSize=20</code>). Simple to use, easy to cache, but can
    be inconsistent if data changes rapidly. Suitable for user-facing grids and
    non-realtime data.
  </li>
  <li>
    <strong>Cursor-Based:</strong> Uses a cursor or token to fetch the next set
    (<code>cursor=abc123</code>). Handles real-time data well and prevents
    duplicates or missing data when listings change during pagination. More
    complex for basic UIs, but needed for feeds or chats.
  </li>
</ul>
<p>
  For our hotel listing, <strong>page-based pagination</strong> is enough
  because listings don’t change rapidly, and users expect to click through
  pages.
</p>
<hr />
<h3>API Endpoint Design &amp; Client Data Model</h3>
<p>
  Here are the core endpoints, shown as TypeScript response types so you can see
  the shape of the server’s JSON output.
</p>
<p>You can also use this for your client data model for your useContext.</p>
<pre><code>
// --- Shared Types ---

export type User = {
id: string;
name: string;
avatarUrl?: string;
};

export type Hotel = {
id: string;
title: string;
pricePerNight: number;
currency: string; // ISO code, e.g., "USD"
images: string[];
location: string;
rating: number;
};

// --- API: Get Hotels (public endpoint) ---
// GET /api/hotels?page=1&amp;pageSize=20

// Request headers (for authenticated user, optional for this endpoint):
// Authorization: Bearer &lt;JWT&gt;
// Accept-Language: en-US
// X-Currency: USD

export type GetHotelsResponse = {
hotels: Hotel[];
page: number;
pageSize: number;
total: number;
};

// --- API: Get Hotel Details (public endpoint) ---
// GET /api/hotels/:id

// Request headers (optional):
// Authorization: Bearer &lt;JWT&gt;
// Accept-Language: en-US
// X-Currency: USD

export type Review = {
user: User;
comment: string;
rating: number;
};

export type GetHotelDetailResponse = Hotel &amp; {
description: string;
amenities: string[];
address: string;
reviews: Review[];
};

// --- Error Response (all endpoints) ---
export type ErrorResponse = {
error: string;
message: string;
status: number;
};
</code></pre>

<h3>Explanation</h3>
<ul>
  <li>
    <strong>GET /api/hotels: </strong>Returns a paginated list of hotels or
    houses. Each hotel object includes core fields and a set of image URLs for
    the slideshow. Pagination is done via <code>page</code> and
    <code>pageSize</code> query params. You can pass
    <code>Accept-Language</code> or <code>X-Currency</code> headers for
    localized/currency-aware pricing.
  </li>
  <li>
    <strong>GET /api/hotels/:id</strong>Returns detailed info for a single
    hotel. This expands the listing data and adds amenities, address, and
    reviews.
  </li>
  <li>
    <strong>Error responses: </strong>All errors return a JSON object with an
    error string, a human-readable message, and a status code.
  </li>
</ul>
<p>
  In production, you’ll also want to protect POST/PUT/DELETE endpoints with
  authentication. Hotel lists and details fetches can be public for our use
  case, but booking or user info would require a Bearer token.
</p>
<hr />
<h2>Image Slider Design for Each Tile</h2>
<p>
  Each tile features an interactive image slider for a modern hotel grid that
  lets users scroll or swipe through property photos. This is a critical
  component for user experience and conversion, so it needs to be fast,
  touch-friendly, and visually smooth.
</p>
<h3>Component Structure</h3>
<p>
  Here’s how the component tree looks for a single tile with an image slider:
</p>
<pre><code>
&lt;BookingsCard&gt;
  &lt;ImageSlider images=[...] /&gt;
&lt;/BookingsCard&gt;
</code></pre>
<p>
  <code>BookingsCard</code> handles the property’s details and hosts the
  <code>ImageSlider</code> component manages image navigation, touch events, and
  progressive image loading.
</p>
<h3>Libraries vs Custom Implementation</h3>
<ul>
  <li>
    <strong>Using a library</strong>:<br />
    There are many well-tested React image carousel libraries like
    <code>react-slick</code>, <code>swiper.js</code>, and
    <code>keen-slider</code>. These offer built-in touch, swipe, keyboard, and
    lazy-loading support.
    <ul>
      <li>
        <strong>Pros:</strong> Quick setup, polished UX, accessible, responsive
        out of the box, battle-tested for edge cases.
      </li>
      <li>
        <strong>Cons:</strong> Adds to bundle size, less flexibility for deep
        customization, sometimes overkill for basic sliders.
      </li>
    </ul>
  </li>
  <li>
    <strong>Custom build</strong>:<br />
    You can build your slider with React, using React <code>useState</code> for
    the index, and CSS for transitions.
    <ul>
      <li>
        <strong>Pros:</strong> Minimal code, complete control, can be tiny for
        simple use cases.
      </li>
      <li>
        <strong>The cons:</strong> You must handle accessibility, swipe
        gestures, and performance optimizations yourself, which takes extra time
        and can introduce bugs.
      </li>
    </ul>
  </li>
</ul>
<p>
  For production, <strong>using a well-known library</strong> like
  <code>swiper.js</code> or It <code>react-slick</code> is usually the best bet,
  they’re optimized, accessible, and you avoid reinventing the wheel.
</p>
<h3>Performance Best Practices</h3>
<ul>
  <li>
    <strong>Memoize the ImageSlider</strong>:<br />
    Use <code>React.memo</code> or <code>useMemo</code> So the slider doesn’t
    re-render unless its props (the images) change. This is especially important
    in a grid where dozens of sliders are visible at once.
  </li>
  <li>
    <strong>Prevent unnecessary image fetches</strong>:<br />
    Only fetch images that haven’t already been loaded. Use browser caching or a
    custom image cache to avoid redundant network requests.
  </li>
  <li>
    <strong>Lazy load images</strong>:<br />
    By default, only load the first image. When a user clicks or swipes to the
    next image, fetch and render it just in time.
  </li>
  <li>
    <strong>Prefetch on desktop hover</strong>:<br />
    If a user hovers over a desktop tile, start prefetching the next image or
    two in the background. This makes navigation instant when the user clicks
    next.
  </li>
  <li>
    <strong>Progressive image loading</strong>:<br />
    Start with a low-res placeholder or blurred version, then swap in the
    full-res image when it finishes loading. Libraries like
    <code>react-lazyload</code> or native
    <code>&lt;img loading="lazy"&gt;</code> can help here.
  </li>
</ul>
<p>
  Using a battle-tested library and layering on bright lazy loading and caching
  gives you a smooth, responsive slider without hammering bandwidth or
  sacrificing UX.
</p>
<hr />
<h2>Optimizations: Graceful Loading, Failures, and More</h2>
<p>
  For a hotel grid like this, the user experience is defined not just by fast
  loading, but by how gracefully the UI handles slow networks, image errors, and
  partial loads. Here’s how to design robust, resilient image and tile loading.
</p>
<h3>Graceful Loading States</h3>
<ul>
  <li>
    <strong>Image Loading Indicators:</strong><br />
    Show a spinner, skeleton, or blurred placeholder while an image loads. The
    <code>onLoad</code> event on the <code>&lt;img&gt;</code> lets you trigger
    the swap to the real image when it’s ready.
  </li>
  <li>
    <strong>Tile Placeholders:</strong><br />
    While hotel data is being fetched, render card skeletons or shimmer
    placeholders. This prevents layout shift and keeps the grid visually stable
    as content comes in.
  </li>
  <li>
    <strong>Lazy Loading Tiles and Images:</strong><br />
    Use <code>&lt;img loading="lazy"&gt;</code> Or intersection observers to
    load images only when a tile is about to scroll into view. React’s
    <code>lazy()</code> and <code>Suspense</code> Let you defer loading heavy
    components until needed.
  </li>
</ul>
<h3>Error Handling and Smart Retry Logic</h3>
<ul>
  <li>
    <strong>onError Handling:</strong><br />
    If an image fails to load, show a fallback image, a “broken” icon, or a
    user-friendly message. Never leave a blank space or broken UI.
  </li>
  <li>
    <strong>Smart Retries:</strong><br />
    Automatically retry loading failed images a few times with a delay, then
    fall back to a static error image. Use exponential backoff for retries to
    avoid hammering the server.
  </li>
  <li>
    <strong>Graceful Failures:</strong><br />
    If a tile’s data can’t be fetched (due to network or server error), display
    a card-level error message with a “retry” button, not just a blank space.
  </li>
  <li>
    <strong>CDN Delivery:</strong><br />
    Host images and static assets on a Content Delivery Network (CDN) for lower
    latency and higher availability. This means images still load quickly even
    if your main API is slow.
  </li>
</ul>
<h3>Other Key Optimizations</h3>
<ul>
  <li>
    <strong>Progressive Image Loading:</strong><br />
    Load a tiny, blurred version first and fade in the high-res image for a
    smoother effect.
  </li>
  <li>
    <strong>Resource Preloading:</strong><br />
    Use <code>&lt;link rel="preload"&gt;</code> for above-the-fold images and
    critical resources. On desktop, prefetch images on hover.
  </li>
  <li>
    <strong>Component Memoization:</strong><br />
    Use <code>React.memo</code> and <code>useMemo</code> to prevent unnecessary
    re-renders, especially for image sliders and hotel cards that receive the
    same props.
  </li>
  <li>
    <strong>Minimize Layout Shift:</strong><br />
    Always set explicit image width and height in Core Web Vitals to avoid
    Cumulative Layout Shift (CLS) penalties.
  </li>
  <li>
    <strong>Accessibility:</strong><br />
    Make sure fallback images have <code>alt</code> text, and use ARIA labels
    for loading states so screen readers aren’t left out.
  </li>
  <li>
    <strong>Cache Control:</strong><br />
    Set appropriate cache headers for API responses and images to reduce load
    times on repeat visits.
  </li>
</ul>
<p>
  With these optimizations in place, your frontend will stay fast, reliable, and
  smooth, even on slow networks or partial failures. Users will never see a
  broken experience, and your grid will always feel modern and responsive.
</p>
<hr />
<h2>Accessibility and Security</h2>
<h3>Accessibility (a11y)</h3>
<ul>
  <li>
    <strong>Keyboard Navigation:</strong><br />
    All interactive elements (image sliders, buttons, tiles) should be fully
    navigable with the keyboard. Use <code>tabIndex</code> for custom components
    and ensure focus styles are visible.
  </li>
  <li>
    <strong>Screen Reader Support:</strong><br />
    Use semantic HTML and ARIA roles/labels to describe tiles, images, buttons,
    and loading states. Each hotel card should have descriptive
    <code>alt</code> text for images, and the slider controls should be
    announced as previous/next image buttons.
  </li>
  <li>
    <strong>Color Contrast:</strong><br />
    Make sure text and controls meet minimum contrast ratios for readability,
    even in low-vision or high-contrast mode.
  </li>
  <li>
    <strong>Accessible Loading/Error States:</strong><br />
    Loading spinners and error messages should be labeled with
    <code>aria-live</code> so screen readers announce changes in real time.
  </li>
  <li>
    <strong>Touch and Pointer Support:</strong><br />
    Sliders and buttons should respond to both mouse and touch events, making
    the app usable on any device.
  </li>
</ul>
<h3>Security</h3>
<ul>
  <li>
    <strong>XSS (Cross-Site Scripting) Protection:</strong><br />
    Never render raw HTML from user-generated content. Always sanitize or escape
    text. Use React’s default escaping for text content, and if you ever use
    <code>dangerouslySetInnerHTML</code>, sanitize first.
  </li>
  <li>
    <strong>CORS (Cross-Origin Resource Sharing):</strong><br />
    Set up your backend API and CDN with appropriate CORS headers to restrict
    which domains can access your resources. Only allow trusted origins (your
    frontend domain).
  </li>
  <li>
    <strong>HTTPS Everywhere:</strong><br />
    Serve your site and APIs over HTTPS to protect data in transit, including
    authentication tokens and personal info.
  </li>
  <li>
    <strong>Authentication:</strong><br />
    Use secure tokens (like JWT) for user authentication. Store them in
    HTTP-only cookies or secure storage to prevent access from JavaScript.
  </li>
  <li>
    <strong>Rate Limiting &#038; Abuse Prevention:</strong><br />
    Throttle API requests per user/IP to prevent brute force and abuse. Add
    backend validation on all inputs.
  </li>
  <li>
    <strong>Content Security Policy (CSP):</strong><br />
    Use CSP headers to limit where scripts and resources can load from. This
    mitigates XSS risks even if something gets past your frontend.
  </li>
</ul>
<p>
  By focusing on accessibility from the start and locking down security with
  best practices, you make your booking app usable for everyone and protect your
  users and data from common web threats.
</p>
