<article>
  <h1>Understanding Normalized vs. Non-Normalized Cache</h1>
  <p>
    In a blogging application, caching plays a crucial role in performance and
    efficiency. Let&#8217;s explore the concepts of normalized and
    non-normalized cache using blog posts and their authors as an example.
  </p>
  <section>
    <h2>Data from Server</h2>
    <p>
      Consider this sample data structure fetched from the server, featuring two
      posts by the same author, &#8220;Alice&#8221;:
    </p>
    <pre><code>{
  "posts": [
    {
      "id": "1",
      "title": "My First Post",
      "author": {
        "id": "a1",
        "name": "Alice"
      }
    },
    {
      "id": "2",
      "title": "Another Day, Another Post",
      "author": {
        "id": "a1",
        "name": "Alice"
      }
    }
  ]
}</code></pre>
  </section>
  <section>
    <h2>Non-Normalized Cache</h2>
    <p>
      In a non-normalized cache, data is stored as received, without any
      alteration. Here&#8217;s how it might look:
    </p>
    <pre><code>{
  "posts": [
    {
      "id": "1",
      "title": "My First Post",
      "author": {
        "id": "a1",
        "name": "Alice"
      }
    },
    {
      "id": "2",
      "title": "Another Day, Another Post",
      "author": {
        "id": "a1",
        "name": "Alice"
      }
    }
  ]
}</code></pre>
    <p>
      This approach leads to redundancy and inefficiency, particularly when
      updating shared data like the author&#8217;s name.
    </p>
  </section>
  <section>
    <h2>Normalized Cache</h2>
    <p>
      A normalized cache, on the other hand, structures data by unique
      identifiers, as shown below:
    </p>
    <pre><code>{
  "Post": {
    "1": {
      "id": "1",
      "title": "My First Post",
      "authorId": "a1"
    },
    "2": {
      "id": "2",
      "title": "Another Day, Another Post",
      "authorId": "a1"
    }
  },
  "Author": {
    "a1": {
      "id": "a1",
      "name": "Alice"
    }
  }
}</code></pre>
    <p>
      This method ensures data integrity, avoids redundancy, and is more
      space-efficient. Relationships are maintained through references like
      &#8220;authorId.&#8221;
    </p>
  </section>
  <p>
    While normalized caching adds a layer of complexity, particularly in
    reconstructing data relationships, it offers significant benefits in
    large-scale applications. Tools like Apollo Client greatly simplify managing
    these challenges.
  </p>
</article>
