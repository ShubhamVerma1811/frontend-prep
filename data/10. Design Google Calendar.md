<h1>Design Google Calendar &#8211; Frontend System Design</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-596"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/1_hGA3brGOXFqxIGh0uq1rNg.png"
    alt=""
    width="975"
    height="501"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/1_hGA3brGOXFqxIGh0uq1rNg.png         975w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/1_hGA3brGOXFqxIGh0uq1rNg-300x154.png 300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/1_hGA3brGOXFqxIGh0uq1rNg-768x395.png 768w
    "
    sizes="(max-width: 975px) 100vw, 975px"
  />
</p>
<h2>Introduction</h2>
<p>
  Frontend system design is an essential skill for developers aiming to build
  robust and scalable applications. This article delves into the frontend system
  design of a Google Calendar-like application. We&#8217;ll walk you through the
  entire process, emphasizing requirements gathering, high-level architecture
  design, API design, edge case management, client data modeling, and
  optimization strategies.
</p>
<p><em>Diagrams are coming soon.</em></p>
<h2>1. Requirements</h2>
<h3>Functional Requirements</h3>
<ol>
  <li class="">
    View Events: Users should be able to view events in daily, weekly, and
    monthly formats.
  </li>
  <li class="">
    Conflict Resolution: The application should detect and provide options to
    resolve conflicting events.
  </li>
  <li class="">
    Create New Events: Users should be able to create new events.
  </li>
</ol>
<p>
  Conflict Resolution in Detail: Conflict resolution involves detecting
  overlapping events and providing users with options to adjust the event times
  to avoid conflicts. We&#8217;ll develop a conflict detection algorithm to
  identify these cases.
</p>
<h3>Non-Functional Requirements</h3>
<ol>
  <li class="">
    Observability: Ensure logging mechanisms to track system health and
    performance, keeping in mind the cost implications of log storage.
  </li>
  <li class="">
    Device Support: The application should be compatible with various devices
    including desktops, tablets, and smartphones.
  </li>
  <li class="">
    Demographics and Accessibility: The design should be inclusive, catering to
    a diverse user base with features like screen readers and keyboard
    navigation for accessibility.
  </li>
  <li class="">
    Performance: Ensure swift loading times and responsiveness to provide a
    seamless user experience.
  </li>
</ol>
<h3>2. High-Level Architecture Design</h3>
<h4>Model-View-Controller (MVC) Architecture</h4>
<p>
  In the MVC architecture, the application is divided into three interconnected
  components:
</p>
<ol>
  <li>
    Model: Represents the data layer of the application. It communicates with
    the database and updates the view whenever the data changes.
  </li>
  <li>
    View: Represents the user interface and the presentation of the data. It
    displays the data from the model to the user and sends the user commands to
    the controller.
  </li>
  <li>
    Controller: Interacts with both the model and the view. It takes the user
    input from the view, processes it (with possible updates to the model), and
    returns the output display.
  </li>
</ol>
<h4>High-Level Component Design and Data Flow</h4>
<ul>
  <li class="ql-indent-2">
    Client-Side (Browser):View Components:Calendar View: Displays the calendar
    in daily, weekly, or monthly views.
  </li>
  <li class="ql-indent-2">Event View: Displays details of a selected event.</li>
  <li class="ql-indent-1">
    Event Creation Modal: Allows users to create new events.
  </li>
  <li class="ql-indent-2">
    Server-Side:Controller Components:Event Controller: Manages the creation,
    viewing, and editing of events.
  </li>
  <li class="ql-indent-1">
    Conflict Resolution Controller: Manages the detection and resolution of
    conflicting events.
  </li>
  <li class="ql-indent-2">
    Database:Model Components:Event Model: Stores the event details such as
    title, date, time, location, and attendees.
  </li>
  <li class="ql-indent-1">
    User Model: Stores user information, preferences, and event associations.
  </li>
</ul>
<h4>Data Flow:</h4>
<ol>
  <li>The view sends a user request to the controller.</li>
  <li>
    The controller interacts with the model to retrieve/update data based on the
    user request.
  </li>
  <li>
    The model interacts with the database to perform CRUD (Create, Read, Update,
    Delete) operations.
  </li>
  <li>The model returns the data to the controller.</li>
  <li>The controller updates the view based on the data from the model.</li>
  <li>The view displays the updated data to the user.</li>
</ol>
<h2>API Design</h2>
<h3>Protocol Choice</h3>
<p>
  For the Google Calendar application, we would primarily be using HTTP/HTTPS as
  the protocol for request-response communication between the client and server.
  Here are the reasons and situations where different techniques would be used:
</p>
<ol>
  <li>
    HTTP/HTTPS (REST): For the basic CRUD operations like creating, reading,
    updating, or deleting events. It is stateless and each request from client
    to server must contain all the information the server needs to fulfill that
    request (like user authentication data).
  </li>
  <li>
    WebSockets: This could be used for real-time updates to the calendar. When
    an event is added/updated by one user, it can be reflected in real-time to
    other users who are viewing the same calendar (if it&#8217;s a shared
    calendar).
  </li>
  <li>
    Long Polling: In situations where real-time updates are not critical, we
    could use Long Polling to reduce the number of HTTP requests made to the
    server. This would be an optimization to consider based on the specific
    requirements and user base of the application.
  </li>
</ol>
<p>
  Given that we don&#8217;t have to deal with real-time, we will choose to go
  with HTTP route.
</p>
<p>Endpoints</p>
<p><strong>Retrieve All Events</strong></p>
<p>Endpoint:</p>
<pre><code>GET /events</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "status": "success",
  "data": [
    {
      "eventId": "12345",
      "title": "Meeting with Bob",
      "date": "2023-09-30",
      "time": "10:00 AM",
      "location": "Room 301",
      "attendees": ["bob@example.com", "alice@example.com"]
    },
    {
      "eventId": "12346",
      "title": "Project Presentation",
      "date": "2023-10-01",
      "time": "02:00 PM",
      "location": "Conference Room",
      "attendees": ["team@example.com"]
    }
  ]
}</code></pre>
<p>&nbsp;</p>
<p><strong>Update an Existing Event</strong></p>
<p>Endpoint:</p>
<pre><code>PUT /events/:eventId</code></pre>
<p>Request Body:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "title": "Meeting with Bob and Alice",
  "date": "2023-09-30",
  "time": "11:00 AM",
  "location": "Room 302",
  "attendees": ["bob@example.com", "alice@example.com"]
}</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "status": "success",
  "data": {
    "eventId": "12345",
    "title": "Meeting with Bob and Alice",
    "date": "2023-09-30",
    "time": "11:00 AM",
    "location": "Room 302",
    "attendees": ["bob@example.com", "alice@example.com"]
  }
}</code></pre>
<p><strong>Delete an Event</strong></p>
<p>Endpoint:</p>
<pre><code>DELETE /events/:eventId</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "status": "success",
  "message": "Event deleted successfully"
}</code></pre>
<p><strong>Get Conflicting Events</strong></p>
<p>Endpoint:</p>
<pre><code>GET /events/conflicts</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "status": "success",
  "data": [
    {
      "eventId": "12345",
      "conflictingEventId": "12347",
      "date": "2023-09-30",
      "time": "10:00 AM to 11:00 AM"
    }
  ]
}</code></pre>
<p><strong>Resolve a Conflicting Event</strong></p>
<p>Endpoint:</p>
<pre><code><code>PUT /events/conflicts/:eventId</code></code></pre>
<p>Request Body:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "resolutionAction": "reschedule",
  "newDate": "2023-10-01",
  "newTime": "09:00 AM"
}</code></pre>
<p>Response:</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  "status": "success",
  "message": "Conflict resolved successfully"
}</code></pre>
<h3>Conflict Detection</h3>
<p>
  The conflict detection phase is a crucial step in maintaining a seamless
  calendar experience. It identifies overlapping events, which could be a
  potential cause of scheduling conflicts. Here&#8217;s how it can be broken
  down step-by-step with examples:
</p>
<p>Step 1: Identify Event Details</p>
<p>
  Explanation: When a user creates or updates an event, the system collects all
  the necessary details related to the event, such as the event date, start
  time, end time, and list of attendees.
</p>
<p>
  Example: A user attempts to schedule a &#8220;Project Kickoff&#8221; meeting
  on September 20th, from 10:00 AM to 11:00 AM, with attendees A, B, and C.
</p>
<p>Step 2: Check Existing Events for Attendees</p>
<p>
  Explanation: The system then cross-references the proposed time slot with
  existing events in the calendar for all the listed attendees. This helps in
  identifying any overlapping events.
</p>
<p>
  Example: The system checks the calendars of attendees A, B, and C for any
  events scheduled from 10:00 AM to 11:00 AM on September 20th.
</p>
<p>Step 3: Conflict Analysis</p>
<p>
  Explanation: If an overlapping event is found, it is flagged as a conflict.
  The system considers various parameters such as the exact time overlap, the
  attendees involved, and the nature of the conflicting event (whether it is a
  one-time event or part of a recurring series).
</p>
<p>
  Example: The system finds that attendee B has a &#8220;Client Meeting&#8221;
  scheduled from 10:30 AM to 11:30 AM on the same day, which conflicts with the
  proposed &#8220;Project Kickoff&#8221; meeting.
</p>
<p>Step 4: Granular Conflict Detection</p>
<p>
  Explanation: In more sophisticated systems, conflict detection can be more
  granular, considering even more aspects such as the location of the event (in
  case of physical meetings), whether the conflicting event can be moved or not,
  etc.
</p>
<p>
  Example: The system notes that the &#8220;Client Meeting&#8221; for attendee B
  is at a different location, and moving it might not be feasible due to the
  logistical constraints.
</p>
<p>Step 5: Conflict Notification Preparation</p>
<p>
  Explanation: Once the conflict is detected, the system prepares to notify the
  user about the conflict, providing detailed information about the conflicting
  events, including who is involved and what the overlapping time slots are.
</p>
<p>
  Example: The system prepares a notification to inform the user that there is a
  conflict with attendee B&#8217;s &#8220;Client Meeting&#8221; from 10:30 AM to
  11:30 AM, suggesting potential resolutions such as rescheduling the
  &#8220;Project Kickoff&#8221; meeting or finding a different time slot that
  suits all attendees.
</p>
<p>Code Example:</p>
<pre><code>function sortEventsByStartTime(events) {
    // Sorts the events by start time in ascending order
    return events.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
}

function detectConflicts(events) {
// Initialize an empty list to store conflict groups
let conflictGroups = [];

    // Helper function to add events to conflict groups
    function addToConflictGroup(event1, event2) {
        for (let group of conflictGroups) {
            if (group.has(event1) || group.has(event2)) {
                group.add(event1);
                group.add(event2);
                return;
            }
        }
        // If neither event is in a conflict group, create a new group
        let newGroup = new Set([event1, event2]);
        conflictGroups.push(newGroup);
    }

    // Sort events by start time
    let sortedEvents = sortEventsByStartTime(events);

    // Iterate over the sorted events and check for conflicts
    for (let i = 0; i < sortedEvents.length - 1; i++) {
        let currentEvent = sortedEvents[i];
        let nextEvent = sortedEvents[i + 1];

        // Check if the current event ends after the next event starts
        if (new Date(currentEvent.endTime) > new Date(nextEvent.startTime)) {
            // A conflict is found, add the events to a conflict group
            addToConflictGroup(currentEvent, nextEvent);
        }
    }

    // Return the list of conflict groups
    return conflictGroups;

}

// Usage:
let events = [
{ startTime: '2023-09-20T09:30:00', endTime: '2023-09-20T10:30:00', attendees: ['B'] },
{ startTime: '2023-09-20T10:00:00', endTime: '2023-09-20T11:00:00', attendees: ['A', 'B', 'C'] },
{ startTime: '2023-09-20T10:30:00', endTime: '2023-09-20T11:30:00', attendees: ['C'] }
];

console.log(detectConflicts(events));
</code></pre>

<h3>Edge Cases</h3>
<p>
  Handling edge cases is a critical part of system design to ensure a robust and
  reliable application. Here are some potential edge cases and how we might
  handle them:
</p>
<ol>
  <li>Concurrent Event Creation:</li>
  <li class="ql-indent-1">
    Scenario: Two or more users attempt to create events that overlap in time
    and involve the same attendees.
  </li>
  <li class="ql-indent-1">
    Solution: Implement an optimistic concurrency control mechanism. When an
    attempt to create an event is made, check for conflicts and notify the user
    if any conflicts exist.
  </li>
  <li>Large Number of Attendees:</li>
  <li class="ql-indent-1">
    Scenario: An event is created with a large number of attendees, potentially
    causing performance issues when checking for conflicts or sending
    notifications.
  </li>
  <li class="ql-indent-1">
    Solution: Implement batch processing for operations like conflict checking
    and notifications, potentially in a background job to avoid blocking the
    main application thread.
  </li>
  <li>Time Zone Differences:</li>
  <li class="ql-indent-1">
    Scenario: Attendees are in different time zones, which can cause confusion
    regarding the timing of events.
  </li>
  <li class="ql-indent-1">
    Solution: Store times in a universal format (like UTC) and convert to the
    local time zone of each attendee when displaying event details or sending
    notifications.
  </li>
  <li>Invalid or Malformed Data Input:</li>
  <li class="ql-indent-1">
    Scenario: A user inputs invalid or malformed data when creating or updating
    an event (e.g., an incorrect date format).
  </li>
  <li class="ql-indent-1">
    Solution: Implement robust input validation to catch invalid or malformed
    data and provide the user with clear error messages.
  </li>
  <li>Failure to Send Notifications:</li>
  <li class="ql-indent-1">
    Scenario: The system fails to send notifications (due to network issues,
    third-party service downtimes, etc.).
  </li>
  <li class="ql-indent-1">
    Solution: Implement a retry mechanism for failed notifications, possibly
    coupled with a logging system to track failed notification attempts and
    address them accordingly.
  </li>
</ol>
<h2>Client Data Model</h2>
<p>
  The Client Data Model is essentially how we structure and manage data on the
  client side. This involves creating data structures to hold events, managing
  the retrieval of data from the server, and implementing mechanisms for
  updating the data when changes occur. Here, I&#8217;ll detail how we might
  build out the client store considering performance, potential caching
  mechanisms, and normalization.
</p>
<h3>Client Store Structure</h3>
<p>
  We would have a centralized store (like Redux or Vuex store) to hold and
  manage the data for the application. The store structure would look something
  like this:
</p>
<pre class="ql-syntax" spellcheck="false"><code>{
  events: [],  // Array to store event objects
  users: [],   // Array to store user objects (attendees)
  views: {     // Object to store current view settings (day, week, month)
    currentView: 'week',
  },
  filters: {}, // Object to store any active filters (like showing only certain calendars)
}</code></pre>
<h3>Performance Considerations</h3>
<p>
  To enhance performance, especially when dealing with a large number of events,
  we would need to consider techniques such as:
</p>
<ol>
  <li>
    Lazy Loading: Load only a subset of events initially and then load more as
    needed.
  </li>
  <li>
    Indexed Lookup: Create indexed lookups for events based on dates or user IDs
    to quickly find relevant events.
  </li>
</ol>
<h3>Caching Mechanisms</h3>
<p>
  To minimize the number of server requests and enhance user experience, we
  might consider:
</p>
<ol>
  <li>
    Service Workers: Implementing service workers to cache server responses
    locally.
  </li>
  <li>
    State Persistence: Persisting the client store locally (like local storage)
    so that it&#8217;s available even after page reloads.
  </li>
</ol>
<h3>Normalization</h3>
<p>
  Normalizing the data structure helps to minimize data redundancy and maintain
  data consistency. For example:
</p>
<ol>
  <li>
    Event Attendees: Instead of storing attendee details directly within event
    objects, we can store user (attendee) objects separately and reference them
    by ID in event objects.
  </li>
</ol>
<h2>Optimizations</h2>
<p>
  In the optimization phase, we will explore various techniques and strategies
  to enhance the application&#8217;s performance, accessibility,
  internationalization, and overall user experience. Here, I will outline
  potential optimizations that can be implemented in the Google Calendar
  application
</p>
<p>1 Virtualization</p>
<p>
  Definition: Virtualization is a technique where we render only a subset of the
  items in the list that are currently visible within the viewport, improving
  the performance significantly when dealing with large lists of data.
</p>
<p>Implementation in Calendar:</p>
<ol>
  <li>
    Event List Virtualization: When displaying a list of events for a
    day/week/month, use a virtualized list to only render the events currently
    in view.
  </li>
  <li>
    Calendar Grid Virtualization: Similarly, when displaying the calendar grid,
    only render the cells that are currently in view.
  </li>
</ol>
<h3>Debouncing/Throttle/Rate Limiting</h3>
<p>
  Definition: These are techniques to limit the number of requests or function
  executions in a given period, enhancing performance and preventing potential
  server overloads.
</p>
<p>Implementation in Calendar:</p>
<ol>
  <li>
    Debouncing: Implement debouncing in the event search functionality to limit
    the number of server requests while the user is typing.
  </li>
  <li>
    Rate Limiting: Limit the rate of API requests to prevent overloading the
    server, especially during mass event updates or uploads.
  </li>
</ol>
<h3>Performance</h3>
<p>Further performance optimizations could include:</p>
<ol>
  <li>
    Minimizing Client-Side Rendering Time: Using techniques like memoization to
    prevent unnecessary re-renders.
  </li>
  <li>
    Optimizing Server Responses: Reducing the size of server responses by using
    techniques like data pagination.
  </li>
</ol>
<h3>Accessibility</h3>
<p>
  Ensuring the application is accessible to all users is crucial. Strategies
  here might involve:
</p>
<ol>
  <li>
    Keyboard Navigation: Ensuring that all functionalities are accessible via
    keyboard.
  </li>
  <li>
    Screen Reader Support: Implementing proper ARIA attributes to support screen
    readers.
  </li>
</ol>
<h3>Internationalization</h3>
<p>
  To support a global user base, we would implement internationalization
  features such as:
</p>
<ol>
  <li>Language Support: Allowing users to select their preferred language.</li>
  <li>
    Time Zone Support: Displaying dates and times according to the user&#8217;s
    time zone.
  </li>
</ol>
<h3>Additional Optimizations</h3>
<p>Other potential optimizations can be:</p>
<ol>
  <li>
    Responsive Design: Ensuring that the application functions well and looks
    good on all device types, including mobiles and tablets.
  </li>
  <li>
    Offline Support: Implementing service workers to allow for offline usage and
    sync once the connection is re-established.
  </li>
</ol>
<h2>Bonus</h2>
<h3>Pagination</h3>
<p>
  When the server returns a substantial number of events, it can potentially
  lead to performance issues, including increased loading times and decreased
  responsiveness. Here are some strategies and updates to our API design to
  manage this effectively:
</p>
<h3>Data Pagination</h3>
<p>
  Explanation: Data pagination involves breaking the data into smaller chunks
  and loading them as needed, rather than retrieving all events at once.
</p>
<p>Implementation in API:</p>
<ul>
  <li>
    Endpoint: <code>GET /events?page=1&amp;limit=100</code> &#8211; This
    endpoint will allow fetching events in pages, with a set number of events
    per page.
  </li>
  <li>
    Client-side: Implement a lazy loading mechanism in the client application to
    load more events as the user scrolls, ensuring a smooth user experience.
  </li>
</ul>
<h3>Data Filtering</h3>
<p>
  Explanation: Implement filtering options in the API to allow the client to
  request only the necessary data, based on various parameters like time range,
  event type, etc.
</p>
<p>Implementation in API, endpoint:</p>
<pre><code>GET /events?startDate=2023-01-01&amp;endDate=2023-01-31</code></pre>
<p>
  This will fetch events within a specified date range, reducing the volume of
  data retrieved in a single request.
</p>
<h3>Data Compression</h3>
<p>
  Explanation: Using data compression techniques to reduce the size of the data
  transmitted between the server and the client.
</p>
<p>Implementation in API:</p>
<ul>
  <li>
    Enable gzip or Brotli compression on the server to reduce the size of the
    API responses.
  </li>
</ul>
<h3>Web Sockets for Real-Time Updates</h3>
<p>
  Explanation: To manage real-time updates more efficiently, especially when
  dealing with a large volume of data.
</p>
<p>Implementation in API:</p>
<ul>
  <li>
    Use WebSockets to push updates to the client, avoiding the need to fetch the
    entire dataset repeatedly.
  </li>
</ul>
<p>
  By implementing these strategies, we can ensure that the application remains
  responsive and provides a seamless user experience, even when handling a large
  volume of events.
</p>
<p>
  In crafting the frontend system design for an application akin to Google
  Calendar, we have traversed through the foundational layers of functional and
  non-functional requirements, delved into the MVC architecture for a seamless
  division of tasks, and outlined the high-level components that make up the
  user experience. We discussed strategies for API communication, from RESTful
  practices to the employment of WebSockets for real-time interaction, and
  addressed the significance of a structured approach to conflict resolution.
  Alongside, we emphasized the importance of observability, device support, and
  a design that champions accessibility and performance. As we prepare to detail
  the diagrams that will bring clarity to our discussed concepts, we acknowledge
  that each design decision we make—from the APIs we craft to the data models we
  architect—serves the paramount goal of delivering an application that not only
  meets the immediate user needs but also anticipates and adapts to the evolving
  dynamics of usage patterns and technological advancements.
</p>
<p>Best of luck in your interview!</p>
