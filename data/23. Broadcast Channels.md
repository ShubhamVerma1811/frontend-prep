<h1>Broadcast Channels Explained</h1>
<p>
  <code>BroadcastChannel</code> is a Web API that provides a simple way for
  different windows or tabs from the same origin to communicate with each other.
  It allows you to send messages between different browsing contexts, such as
  different tabs or windows of the same browser.
</p>
<p>Here&#8217;s how it works:</p>
<ol>
  <li>Creation of a Channel:</li>
</ol>
<ul>
  <li class="ql-indent-1">
    You create a <code>BroadcastChannel</code> object by specifying a channel
    name. This name acts as an identifier for the communication channel.
  </li>
</ul>
<ol>
  <li>Sending Messages:</li>
</ol>
<ul>
  <li class="ql-indent-1">
    You can send messages using the <code>postMessage()</code> method of the
    <code>BroadcastChannel</code> object. This allows you to send data to all
    connected channels.
  </li>
</ul>
<ol>
  <li>Receiving Messages:</li>
</ol>
<ul>
  <li class="ql-indent-1">
    Each channel that has the same name can listen for messages using the
    <code>onmessage</code> event handler.
  </li>
</ul>
<h3>Example Usage:</h3>
<p>
  Let&#8217;s say you have two tabs open in your browser, and you want to enable
  communication between them using a <code>BroadcastChannel</code>.
</p>
<p>Tab 1 (Sender):</p>
<pre class="ql-syntax" spellcheck="false">
const channel = new BroadcastChannel('myChannel'); document.querySelector('button').addEventListener('click', () =&gt; { const message = document.querySelector('input').value; channel.postMessage(message); }); 
</pre>
<p>
  In this example, we create a new <code>BroadcastChannel</code> named
  &#8216;myChannel&#8217;. When the button is clicked, it sends the value of an
  input field as a message through the channel.
</p>
<p>Tab 2 (Receiver):</p>
<pre class="ql-syntax" spellcheck="false">
const channel = new BroadcastChannel('myChannel'); channel.onmessage = function(event) { const message = event.data; console.log('Received message:', message); }; 
</pre>
<p>
  In this example, we create a <code>BroadcastChannel</code> with the same name
  (&#8216;myChannel&#8217;). We then listen for messages using the
  <code>onmessage</code> event handler. When a message is received, we extract
  the data from the event and log it to the console.
</p>
<p>How it Works:</p>
<ol>
  <li>
    When Tab 1 sends a message using <code>channel.postMessage(message)</code>,
    Tab 2 receives it through <code>channel.onmessage</code>.
  </li>
  <li>
    Both tabs use the same channel name (&#8216;myChannel&#8217;) to establish a
    connection.
  </li>
  <li>
    Any message sent through the channel is received by all listening channels
    with the same name.
  </li>
</ol>
<p>Important Considerations:</p>
<ul>
  <li>
    The communicating tabs need to be from the same origin (i.e., same protocol,
    domain, and port) due to same-origin policy restrictions.
  </li>
  <li>
    Messages sent through a <code>BroadcastChannel</code> are serialized, so
    they should be JSON-serializable data.
  </li>
  <li>
    Channels persist as long as at least one script holds a reference to them.
    When all references are released, the channel is closed.
  </li>
</ul>
<p>
  <code>BroadcastChannel</code> is useful for scenarios where you need real-time
  communication between different browsing contexts within your web application,
  such as multiplayer games, collaborative tools, or any situation where you
  want to sync data across multiple windows or tabs.
</p>
