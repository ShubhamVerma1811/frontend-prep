<h1>API Design in Front-End Systems</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1700"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43.png"
    alt="Frontend System Design API Design"
    width="1920"
    height="1080"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43.png          1920w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43-300x169.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43-1024x576.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43-768x432.png   768w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-43-1536x864.png 1536w
    "
    sizes="(max-width: 1920px) 100vw, 1920px"
  />
</p>
<p>
  The API layer is the bridge between your frontend and the backend server.
  Whenever your app needs to load data, create new posts, update content, or
  listen for changes, it communicates with the server through APIs. The protocol
  you choose for this communication depends on the type of application you are
  building and its real-time requirements.
</p>
<blockquote>
  <p>
    <em
      ><strong
        >Please spend no more than 20% of your interview explaining this
        portion.</strong
      ></em
    >
  </p>
</blockquote>
<hr />
<h3>Choosing the Right API Protocol</h3>
<p>
  The choice of API protocol comes down to the application&#8217;s needs. Here’s
  a quick reference table of common front-end application types and the
  protocols that make the most sense for each:
</p>
<table>
  <thead>
    <tr>
      <th>App Type</th>
      <th>Example Feature</th>
      <th>Recommended API Protocol</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Chat Application</td>
      <td>Real-time messaging between users</td>
      <td>WebSockets</td>
    </tr>
    <tr>
      <td>News Feed</td>
      <td>Scrolling to load posts, pulling new content</td>
      <td>HTTP REST</td>
    </tr>
    <tr>
      <td>Live Notifications</td>
      <td>Instant alerts or status updates</td>
      <td>Server-Sent Events (SSE) or WebSockets</td>
    </tr>
    <tr>
      <td>Collaborative Editing</td>
      <td>Multiple users editing the same document</td>
      <td>WebSockets</td>
    </tr>
    <tr>
      <td>AI/Streaming Response</td>
      <td>Streaming generated text (like ChatGPT)</td>
      <td>Server-Sent Events (SSE)</td>
    </tr>
    <tr>
      <td>Profile or Settings Management</td>
      <td>Fetching and updating user preferences</td>
      <td>HTTP REST or GraphQL</td>
    </tr>
    <tr>
      <td>Analytics Dashboard</td>
      <td>Loading and filtering reports or metrics</td>
      <td>HTTP REST or GraphQL</td>
    </tr>
  </tbody>
</table>
<hr />
<h3>Designing API Endpoints Example: Facebook-Style News Feed</h3>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-567"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.16-PM.png"
    alt="Frontend System Design API Design"
    width="676"
    height="335"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.16-PM.png         676w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.16-PM-300x149.png 300w
    "
    sizes="(max-width: 676px) 100vw, 676px"
  />
</p>
<p>
  Most data fetching can be handled with HTTP-based APIs for a typical news feed
  or social app. GraphQL is an excellent choice if your data is complex and
  clients want to specify what fields they need. Below is a set of example
  endpoints for a Facebook-style feed, showing how you might structure queries
  and mutations for getting a feed, getting a specific feed item, and creating a
  new post.
</p>
<pre><code class="language-graphql">
// Get Feed (Cursor-based pagination)
GET /api/v1/gql/feed
Input: {
  cursor: string,       // Optional, points to the last item from the previous fetch
  limit: number,        // How many items to fetch
  post_types: [PostType], // filter feed items by type
  // ...other filters
}
Headers: {
  user_id: string // used for authentication and personalized feeds
}
// Response: List of FeedItems, next cursor, etc.

// Get Feed Item
GET /api/v1/gql/feed-item
Input: {
post_id: string
}
Headers: {
user_id: string
}
// Response: Single FeedItem with comments and metadata

// Create Post
POST /api/v1/gql/create-feed-post
Input: {
title: String,
media: [Media],
// ...other post fields
}
Headers: {
user_id: string
}
// Response: Status code, created post ID, errors if any
</code></pre>

<hr />
<h3>Expected Response: News Feed Example</h3>
<pre><code class="language-json">
{
  "data": [
    {
      "id": "post1",
      "author": { "id": "user1", "name": "Alice" },
      "content": "Hello world",
      "createdAt": "2024-05-19T18:24:00Z",
      "media": [{ "url": "...", "type": "image" }],
      "comments": [
        { "id": "comment1", "author": { "id": "user2", "name": "Bob" }, "text": "Nice post!" }
      ]
    },
    // more posts...
  ],
  "nextCursor": "YXJyYXljb25uZWN0aW9uOjEw",  // base64 encoded cursor for next fetch
  "hasMore": true
}
</code></pre>
<hr />
<h3>Why Cursor-Based Pagination?</h3>
<p>
  Cursor-based pagination is preferred for news feeds and infinite scrolling
  because it is more robust when data changes rapidly. Unlike page-based
  pagination (pages 1, 2, and 3), which can show duplicate or missing results if
  new posts are added or old ones are deleted between requests, cursor-based
  pagination always starts from the last item received. This keeps the data
  consistent as the user scrolls and ensures smooth UX even as new posts arrive.
</p>
<p>
  Cursor-based approaches are also more scalable for large datasets and prevent
  issues with users seeing the duplicate content twice or skipping content when
  the feed updates quickly. The server returns a cursor pointing to the
  following item, which the client uses to fetch the next set of results.
</p>
<hr />
<h3>Best Practices for API Design</h3>
<ul>
  <li>
    <strong>Version your API:</strong> Always include a version number in your
    API path, such as <code>/api/v1/...</code>, to avoid breaking changes for
    clients when you need to evolve your API over time.
  </li>
  <li>
    <strong>Consistent naming conventions:</strong> Use clear, predictable
    endpoint names and stick to a consistent case (camelCase or snake_case).
  </li>
  <li>
    <strong>Authentication:</strong> Pass authentication tokens or user IDs
    using secure headers. Avoid sensitive data in URLs or query parameters.
  </li>
  <li>
    <strong>Explicit status codes:</strong> Always return the correct HTTP
    status codes for success, errors, or unauthorized requests (200, 201, 400,
    401, 404, 500, etc).
  </li>
  <li>
    <strong>Clear error messages:</strong> Provide meaningful error objects with
    error codes and messages so the frontend can handle problems gracefully.
  </li>
  <li>
    <strong>Flexible filtering and sorting:</strong> Allow clients to filter,
    sort, and paginate data to reduce unnecessary payloads and improve
    performance.
  </li>
  <li>
    <strong>Minimal over-fetching:</strong> With GraphQL or well-designed REST,
    the client can specify which fields to use to reduce bandwidth and improve
    speed.
  </li>
  <li>
    <strong>Documentation:</strong> Keep API contracts well-documented and
    updated so frontend and backend teams stay in sync.
  </li>
</ul>
<p>
  Good API design keeps your frontend flexible, makes your system easy to debug,
  and allows you to scale easily as your product grows.
</p>
<hr />
<p>&nbsp;</p>
<h3>API Request Headers and Response Format</h3>
<p>
  Every API call your frontend makes should clearly define what headers are sent
  and what response body is expected in return. Proper headers ensure security,
  user personalization, and reliable communication. The response structure
  should be predictable and easy to transform into your client-side data store.
</p>
<h4>Common Request Headers</h4>
<ul>
  <li>
    <strong>Authorization</strong>: <code>Bearer &lt;token&gt;</code> – used for
    authenticating the user session.
  </li>
  <li>
    <strong>Content-Type</strong>: <code>application/json</code> – specifies the
    format of the request body.
  </li>
  <li>
    <strong>X-User-ID</strong>: User identifier for tracking or personalization
    (when sessions are stateless).
  </li>
  <li>
    <strong>Accept-Language</strong>: Sets the preferred language for localized
    responses.
  </li>
  <li>
    <strong>X-Request-ID</strong>: Optional, used for tracing and debugging
    across distributed systems.
  </li>
</ul>
<pre><code class="language-http">
GET /api/v1/gql/feed
Authorization: Bearer eyJhbGciOi...
Content-Type: application/json
X-User-ID: user_12345
Accept-Language: en-US
X-Request-ID: 123e4567-e89b-12d3-a456-426614174000
</code></pre>
<h4>Expected Response Body</h4>
<p>
  The response body should return all necessary information for rendering the UI
  and updating your client data model. Here’s a sample for a feed endpoint:
</p>
<pre><code class="language-json">
{
  "data": [
    {
      "id": "post_1",
      "author": {
        "id": "user_123",
        "name": "Alice"
      },
      "content": "Hello world",
      "createdAt": "2024-05-19T18:24:00Z",
      "media": [
        { "url": "https://cdn.example.com/image1.jpg", "type": "image" }
      ],
      "comments": [
        {
          "id": "comment_1",
          "author": {
            "id": "user_456",
            "name": "Bob"
          },
          "text": "Nice post!",
          "createdAt": "2024-05-19T18:25:00Z"
        }
      ]
    }
    // ...more posts
  ],
  "nextCursor": "YXJyYXljb25uZWN0aW9uOjEw",
  "hasMore": true
}
</code></pre>
<h4>Transforming the Response on the Client</h4>
<p>
  When the response arrives, map and normalize the data to match your local
  client data model. Extract users, posts, and comments into separate entities
  for easier updates and caching. This makes rendering faster and future data
  changes more predictable.
</p>
<hr />
<p>
  Next up, let&#8217;s finally discuss the <strong>O in R.A.D.I.O</strong>,
  which is <strong>Optimizations</strong>.
</p>
