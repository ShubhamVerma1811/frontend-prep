<h1>State and Client Data Model In Frontend System Design</h1>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-1696"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41.png"
    alt="Frontend System Design Data Model"
    width="1920"
    height="1080"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41.png          1920w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41-300x169.png   300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41-1024x576.png 1024w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41-768x432.png   768w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/FrontendLead-41-1536x864.png 1536w
    "
    sizes="(max-width: 1920px) 100vw, 1920px"
  />
</p>
<p class="" data-start="177" data-end="440">
  In this portion of the interview, spend about half your time discussing how
  you’ll handle state on the client, and the other half on the actual data model
  you’ll use in your frontend.
</p>
<p data-start="177" data-end="440">
  <em
    ><strong
      >Please spend no more than 15% of your interview explaining this
      portion.</strong
    ></em
  >
</p>
<hr />
<h2 data-start="442" data-end="476">State Management on the Client</h2>
<p class="" data-start="478" data-end="698">
  State management is one of those things everyone has an opinion about. There
  are plenty of options, each with its strengths and trade-offs.
</p>
<p class="" data-start="478" data-end="698">
  Here are the most common choices you’ll see in real-world frontend projects.
</p>
<div class="_tableContainer_16hzy_1">
  <div
    class="_tableWrapper_16hzy_14 group flex w-fit flex-col-reverse"
    tabindex="-1"
  >
    <table
      class="w-fit min-w-(--thread-content-width)"
      data-start="700"
      data-end="1557"
    >
      <thead data-start="700" data-end="730">
        <tr data-start="700" data-end="730">
          <th data-start="700" data-end="715" data-col-size="sm">Type</th>
          <th data-start="715" data-end="730" data-col-size="xl">
            Description
          </th>
        </tr>
      </thead>
      <tbody data-start="762" data-end="1557">
        <tr data-start="762" data-end="887">
          <td data-start="762" data-end="777" data-col-size="sm">useState</td>
          <td data-start="777" data-end="887" data-col-size="xl">
            React&#8217;s built-in hook manages the local component state. It is
            best for isolated UI pieces or small components.
          </td>
        </tr>
        <tr data-start="888" data-end="1072">
          <td data-start="888" data-end="903" data-col-size="sm">useContext</td>
          <td data-start="903" data-end="1072" data-col-size="xl">
            Built-in React API for passing data through the component tree
            without prop drilling. Works well for global values like
            authentication, themes, or language settings.
          </td>
        </tr>
        <tr data-start="1073" data-end="1215">
          <td data-start="1073" data-end="1088" data-col-size="sm">Redux</td>
          <td data-start="1088" data-end="1215" data-col-size="xl">
            Powerful state management library for large, complex apps that need
            global state and strict control over how state changes.
          </td>
        </tr>
        <tr data-start="1216" data-end="1336">
          <td data-start="1216" data-end="1231" data-col-size="sm">Recoil</td>
          <td data-start="1231" data-end="1336" data-col-size="xl">
            Provides atomic state and derived data, making managing and sharing
            state across components easier.
          </td>
        </tr>
        <tr data-start="1337" data-end="1451">
          <td data-start="1337" data-end="1352" data-col-size="sm">Zustand</td>
          <td data-start="1352" data-end="1451" data-col-size="xl">
            Minimalistic and flexible state management, simple API, good
            performance for medium-sized apps.
          </td>
        </tr>
        <tr data-start="1452" data-end="1557">
          <td data-start="1452" data-end="1467" data-col-size="sm">MobX</td>
          <td data-col-size="xl" data-start="1467" data-end="1557">
            Uses observables for automatic state tracking, helps with complex
            reactivity patterns.
          </td>
        </tr>
      </tbody>
    </table>
    <div class="sticky end-(--thread-content-margin) h-0 self-end select-none">
      <div class="absolute end-0 flex items-end"></div>
    </div>
  </div>
</div>
<p class="" data-start="1559" data-end="1736">
  A combination of useContext and useState for most front-end apps covers most
  cases. It keeps things simple and easy to follow, especially when the app is
  not massive.
</p>
<hr class="" data-start="1738" data-end="1741" />
<h3 class="" data-start="1989" data-end="2027">
  UseContext vs Redux: Pros and Cons
</h3>
<p class="" data-start="2029" data-end="2113">
  If you’re comparing useContext to Redux, it’s pretty clear-cut for most modern
  apps.
</p>
<div class="_tableContainer_16hzy_1">
  <div
    class="_tableWrapper_16hzy_14 group flex w-fit flex-col-reverse"
    tabindex="-1"
  >
    <table
      class="w-fit min-w-(--thread-content-width)"
      data-start="2115"
      data-end="2977"
    >
      <thead data-start="2115" data-end="2222">
        <tr data-start="2115" data-end="2222">
          <th data-start="2115" data-end="2132" data-col-size="sm"></th>
          <th data-start="2132" data-end="2174" data-col-size="sm">
            useContext
          </th>
          <th data-start="2174" data-end="2222" data-col-size="md">Redux</th>
        </tr>
      </thead>
      <tbody data-start="2331" data-end="2977">
        <tr data-start="2331" data-end="2438">
          <td data-start="2331" data-end="2348" data-col-size="sm">Setup</td>
          <td data-start="2348" data-end="2390" data-col-size="sm">
            Minimal, comes with React
          </td>
          <td data-col-size="md" data-start="2390" data-end="2438">
            Lots of setup, external library
          </td>
        </tr>
        <tr data-start="2439" data-end="2546">
          <td data-start="2439" data-end="2456" data-col-size="sm">
            Complexity
          </td>
          <td data-start="2456" data-end="2498" data-col-size="sm">
            Straightforward, easy to reason about
          </td>
          <td data-col-size="md" data-start="2498" data-end="2546">
            Heavy, introduces extra layers and patterns
          </td>
        </tr>
        <tr data-start="2547" data-end="2654">
          <td data-start="2547" data-end="2564" data-col-size="sm">
            Performance
          </td>
          <td data-col-size="sm" data-start="2564" data-end="2606">
            Good for most apps
          </td>
          <td data-col-size="md" data-start="2606" data-end="2654">
            Not better for performance
          </td>
        </tr>
        <tr data-start="2655" data-end="2762">
          <td data-start="2655" data-end="2672" data-col-size="sm">
            Flexibility
          </td>
          <td data-start="2672" data-end="2714" data-col-size="sm">
            Enough for most global data
          </td>
          <td data-col-size="md" data-start="2714" data-end="2762">
            Useful mainly for legacy or massive codebases
          </td>
        </tr>
        <tr data-start="2763" data-end="2869">
          <td data-start="2763" data-end="2780" data-col-size="sm">Tooling</td>
          <td data-col-size="sm" data-start="2780" data-end="2821">Basic</td>
          <td data-col-size="md" data-start="2821" data-end="2869">
            Has its own set of devtools
          </td>
        </tr>
        <tr data-start="2870" data-end="2977">
          <td data-start="2870" data-end="2887" data-col-size="sm">
            Learning Curve
          </td>
          <td data-col-size="sm" data-start="2887" data-end="2929">
            Quick for any React dev
          </td>
          <td data-col-size="md" data-start="2929" data-end="2977">
            Steep and often not worth it
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<p class="" data-start="2766" data-end="2991">
  In most cases, useContext provides everything you need for a global state. It
  keeps things clean, is easy to debug, and doesn’t require learning a whole new
  system.
</p>
<hr />
<h3 class="" data-start="240" data-end="264">Data to be Persisted</h3>
<p class="" data-start="266" data-end="569">
  Sometimes, you need data to persist across page refreshes or support offline
  access. Most of the time, fetching the latest data from the server is enough.
  But if you want to reduce server requests, speed up your app, or enable
  offline support, you’ll need client-side storage.
</p>
<p class="" data-start="571" data-end="762">
  On the web, your main options are local storage, session storage, IndexedDB,
  and cookies. Each has its own strengths and limitations, especially regarding
  storage size and data structure.
</p>
<div class="_tableContainer_16hzy_1">
  <div
    class="_tableWrapper_16hzy_14 group flex w-fit flex-col-reverse"
    tabindex="-1"
  >
    <table
      class="w-fit min-w-(--thread-content-width)"
      data-start="764"
      data-end="1585"
    >
      <thead data-start="764" data-end="900">
        <tr data-start="764" data-end="900">
          <th data-start="764" data-end="783" data-col-size="sm">
            Storage Type
          </th>
          <th data-start="783" data-end="845" data-col-size="md">Pros</th>
          <th data-start="845" data-end="900" data-col-size="md">Cons</th>
        </tr>
      </thead>
      <tbody data-start="1038" data-end="1585">
        <tr data-start="1038" data-end="1174">
          <td data-start="1038" data-end="1057" data-col-size="sm">
            Local Storage
          </td>
          <td data-start="1057" data-end="1119" data-col-size="md">
            Simple, persists after refresh, easy to use
          </td>
          <td data-col-size="md" data-start="1119" data-end="1174">
            Synchronous, small size limit, plain string values
          </td>
        </tr>
        <tr data-start="1175" data-end="1311">
          <td data-start="1175" data-end="1194" data-col-size="sm">
            Session Storage
          </td>
          <td data-start="1194" data-end="1256" data-col-size="md">
            Same as local storage, but data clears on tab close
          </td>
          <td data-col-size="md" data-start="1256" data-end="1311">
            Data lost on close, small size limit
          </td>
        </tr>
        <tr data-start="1312" data-end="1448">
          <td data-start="1312" data-end="1331" data-col-size="sm">
            IndexedDB
          </td>
          <td data-start="1331" data-end="1393" data-col-size="md">
            Ample storage, supports complex objects, asynchronous
          </td>
          <td data-col-size="md" data-start="1393" data-end="1448">
            API is more complex, browser quirks
          </td>
        </tr>
        <tr data-start="1449" data-end="1585">
          <td data-start="1449" data-end="1468" data-col-size="sm">Cookies</td>
          <td data-col-size="md" data-start="1468" data-end="1530">
            Sent with requests, used for auth/session
          </td>
          <td data-col-size="md" data-start="1530" data-end="1585">
            Tiny size, less secure, and outdated for data
          </td>
        </tr>
      </tbody>
    </table>
    <div class="sticky end-(--thread-content-margin) h-0 self-end select-none">
      <div class="absolute end-0 flex items-end"></div>
    </div>
  </div>
</div>
<hr />
<h3 data-start="1587" data-end="1938">Scoped vs Global State</h3>
<p class="" data-start="1587" data-end="1938">
  When it comes to state, it’s crucial not to default to global state for
  everything. Most of the time, having a scoped state at the component or
  feature level simplifies and makes your app more performant. Only reach for
  global state (with tools like useContext) when you truly need to share data
  between different views or parts of your app.
</p>
<p class="" data-start="1940" data-end="2035">
  Here’s a quick table comparing scoped state to global state, especially in
  terms of re-renders:
</p>
<div class="_tableContainer_16hzy_1">
  <div
    class="_tableWrapper_16hzy_14 group flex w-fit flex-col-reverse"
    tabindex="-1"
  >
    <table
      class="w-fit min-w-(--thread-content-width)"
      data-start="2037"
      data-end="2660"
    >
      <thead data-start="2037" data-end="2149">
        <tr data-start="2037" data-end="2149">
          <th data-start="2037" data-end="2055" data-col-size="sm">
            State Type
          </th>
          <th data-start="2055" data-end="2106" data-col-size="md">Use Case</th>
          <th data-start="2106" data-end="2149" data-col-size="lg">
            Impact on Re-renders
          </th>
        </tr>
      </thead>
      <tbody data-start="2263" data-end="2660">
        <tr data-start="2263" data-end="2443">
          <td data-start="2263" data-end="2281" data-col-size="sm">
            Scoped State
          </td>
          <td data-col-size="md" data-start="2281" data-end="2332">
            State used only in one component or a small subtree
          </td>
          <td data-col-size="lg" data-start="2332" data-end="2443">
            Only the owning component and its children re-render when the state
            changes. Keeps updates local and efficient.
          </td>
        </tr>
        <tr data-start="2444" data-end="2660">
          <td data-start="2444" data-end="2462" data-col-size="sm">
            Global State
          </td>
          <td data-col-size="md" data-start="2462" data-end="2521">
            State is shared across multiple views or distant components
          </td>
          <td data-col-size="lg" data-start="2521" data-end="2660">
            All components that consume the global state will re-render on any
            state change, which can impact performance if not managed carefully.
          </td>
        </tr>
      </tbody>
    </table>
    <div class="sticky end-(--thread-content-margin) h-0 self-end select-none">
      <div class="absolute end-0 flex items-end"></div>
    </div>
  </div>
</div>
<p class="" data-start="2662" data-end="2805">
  Choosing the proper scope for your state helps avoid unnecessary re-renders
  and keeps your app fast. Use global state only when truly necessary.
</p>
<p class="" data-start="1780" data-end="1837">
  Next up, an example for building out a client data model.
</p>
<hr />
<h2>Client Data Model</h2>
<p>
  <img
    loading="lazy"
    decoding="async"
    class="alignnone size-full wp-image-563"
    src="https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.42-PM.png"
    alt=""
    width="815"
    height="335"
    srcset="
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.42-PM.png         815w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.42-PM-300x123.png 300w,
      https://api.frontendlead.com/wp-content/uploads/2024/03/Screen-Shot-2023-09-15-at-2.32.42-PM-768x316.png 768w
    "
    sizes="(max-width: 815px) 100vw, 815px"
  />
</p>
<p>
  A clear and well-defined client data model is the foundation of a reliable
  frontend architecture. The data model lays out the types you need to render
  content on the client, and it should mirror the actual entities your UI works
  with. Good modeling helps keep your state predictable, makes components easier
  to build, and allows for efficient updates and rendering.
</p>
<p>
  When building out your client data model, start by identifying the core
  entities in your app. For a feed-based product, this might include things like
  users, feed items, comments, and user settings. Group related data together
  and keep your types organized, so it&#8217;s clear how each piece of state
  fits into the overall app structure.
</p>
<p>
  The following example demonstrates how to structure your types using
  TypeScript. This approach makes the shape of your data explicit and helps with
  both development and maintenance.
</p>
<pre><code class="language-ts">
// Root app state
type App = {
  user: User;
  settings: UserSettings;
  feed: Feed;
};

// Feed and feed items
type Feed = {
items: FeedItem[];
page: number;
size: number;
};

type FeedItem = {
type: FeedItemType;
creationDate: string;
author: User;
content: FeedItemContent;
comments: FeedItemComment[];
};

type FeedItemContent = {
title: StyledText;
body: StyledText;
media?: Media;
};

// Supporting types
type User = {
name: string;
// ...other user fields
};

type UserSettings = {
timeZone: string;
accessibilityPreferences: AccessibilityPreferences;
// ...other settings
};

type FeedItemComment = {
author: User;
content: StyledText;
creationDate: string;
// ...other comment fields
};

type StyledText = {
// Rich text, colors, links, mentions, etc.
// Server-driven UI structure
};

type Media = {
url: string;
type: 'image' | 'video' | 'audio';
// ...other media fields
};

type FeedItemType = 'post' | 'announcement' | 'update'; // Example types

type AccessibilityPreferences = {
fontSize: string;
contrastMode: boolean;
// ...other preferences
};
</code></pre>

<p>
  In this model, each type is built for a clear responsibility. The
  <code>App</code> root type holds the user, settings, and feed data. The
  <code>Feed</code> list contains <code>FeedItem</code> objects, each with
  metadata, content, and comments. Content and comments use a
  <code>StyledText</code> structure to support rich text, colors, links, and
  mentions. User settings are scoped to the user, making room for accessibility
  features.
</p>
<p>
  Modeling your client data this way keeps the shape of your state explicit, so
  you always know what to expect in your components. It also sets you up for
  scalable code, as new features or entities can be added to the types without
  significant rewrites. Well-structured models lead to easier debugging and
  better overall performance on your front end.
</p>
<p>&nbsp;</p>
<hr />
<h2>Data Normalization</h2>
<p>
  Whenever possible, aim for a normalized data structure on the client.
  Normalization means storing each entity type (like users, posts, and comments)
  separately by ID rather than nesting full objects within other objects. This
  approach avoids data duplication, keeps your state consistent, and simplifies
  updates.
</p>
<p>Here’s a quick example of a non-normalized versus normalized state shape:</p>
<p><strong>Non-normalized:</strong></p>
<pre><code class="language-ts">
const feed = [
  {
    id: "post1",
    author: { id: "user1", name: "Alice" },
    content: "Hello world",
    comments: [
      { id: "comment1", author: { id: "user2", name: "Bob" }, text: "Nice post!" }
    ]
  }
];
</code></pre>
<p><strong>Normalized:</strong></p>
<pre><code class="language-ts">
const users = {
  user1: { id: "user1", name: "Alice" },
  user2: { id: "user2", name: "Bob" }
};

const posts = {
post1: {
id: "post1",
authorId: "user1",
content: "Hello world",
commentIds: ["comment1"]
}
};

const comments = {
comment1: {
id: "comment1",
authorId: "user2",
text: "Nice post!"
}
};
</code></pre>

<p>
  With normalization, updates to a user or comment happen in a single place, and
  you never have to worry about stale or duplicated data across the app. This
  pattern works well for any frontend that handles dynamic or relational data.
</p>
<hr />
<p>
  Next, let&#8217;s move on to the <strong>I in R.A.D.I.O</strong>, which stands
  for Interface design. This is a fancy saying, &#8220;Let&#8217;s build the API
  layer.&#8221;
</p>
